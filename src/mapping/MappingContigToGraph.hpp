
#ifndef MDBG_METAG_MappingContigToGraph
#define MDBG_METAG_MappingContigToGraph

#include "../Commons.hpp"


class MappingContigToGraph : public Tool{
    
public:


	string _outputDir;
	size_t _k;
	int _nbCores;
	bool _generateContigPath;
	bool _generateReadPath;
	string _contigFilename;
	string _contigDataFilename;
	bool _useHomopolymerCompression;

	string _filename_exe;
	string _tmpDir;

	MappingContigToGraph(): Tool (){

	}


	void parseArgs(int argc, char* argv[]){


		_filename_exe = argv[0];

		args::ArgumentParser parser("gfa", ""); //"This is a test program.", "This goes after the options."
		//args::Positional<std::string> arg_contigs(parser, "contigs", "Contig file generated by metaMDBG", args::Options::Required);
		args::Positional<std::string> arg_outputDir(parser, "assemblyDir", "Output dir of a metaMDBG run", args::Options::Required);
		//args::Positional<int> arg_k(parser, "k", "Generate assembly graph for this k-min-mer size value (set to 0 to display available k values and corresponding length in bps)", args::Options::Required);
		args::Positional<std::string> arg_contigFilename(parser, "contigFilename", "Contigs to map", args::Options::Required);
		//args::Positional<std::string> arg_contigDataFilename(parser, "contigDataFilename", "contig_data.txt", args::Options::Required);
		//args::Flag arg_contigpath(parser, "", "Generate path of contigs in the assembly graph", {"contigpath"});
		//args::Flag arg_readpath(parser, "", "Generate path of reads in the assembly graph", {"readpath"});
		args::Flag arg_homopolymerCompression(parser, "", "Activate homopolymer compression", {ARG_HOMOPOLYMER_COMPRESSION});
		args::ValueFlag<int> arg_nbCores(parser, "", "Number of cores", {ARG_NB_CORES2}, NB_CORES_DEFAULT_INT);
		args::Flag arg_help(parser, "", "", {'h', "help"}, args::Options::Hidden);



		try
		{
			parser.ParseCLI(argc, argv);
		}
		catch (const args::Help&)
		{
			cerr << parser;
			exit(0);
		}
		catch (const std::exception& e)
		{
			cerr << parser;
			//_logFile << endl;
			cerr << e.what() << endl;
			exit(0);
		}

		if(arg_help){
			cerr << parser;
			exit(0);
		}



		_outputDir = args::get(arg_outputDir);
		_contigFilename  = args::get(arg_contigFilename);
		_nbCores = args::get(arg_nbCores);

		_useHomopolymerCompression = false;
		if(arg_homopolymerCompression){
			_useHomopolymerCompression = true;
		}

		cout << "Be careful if hifi: activate HPC" << endl;

		if(!fs::exists(_outputDir)){
			cerr << "Assembly dir does not exists" << endl;
			exit(1);
		}

		//_tmpDir = _outputDir + "/tmp/";

		//if(!fs::exists(_tmpDir)){
		//	cerr << "Invalid assembly dir" << endl;
		//	exit(1);
		//}

		//openLogFile(_tmpDir);

		cout << "Assembly dir: " << _outputDir << endl;

	}


    void execute (){

		string filename_parameters = _outputDir + "/parameters.gz";
		gzFile file_parameters = gzopen(filename_parameters.c_str(),"rb");
		gzread(file_parameters, (char*)&_minimizerSize, sizeof(_minimizerSize));
		gzread(file_parameters, (char*)&_kminmerSize, sizeof(_kminmerSize));
		gzread(file_parameters, (char*)&_minimizerDensity, sizeof(_minimizerDensity));
		//gzread(file_parameters, (char*)&_kminmerSizeFirst, sizeof(_kminmerSizeFirst));
		//gzread(file_parameters, (char*)&_minimizerSpacingMean, sizeof(_minimizerSpacingMean));
		//gzread(file_parameters, (char*)&_kminmerLengthMean, sizeof(_kminmerLengthMean));
		//gzread(file_parameters, (char*)&_kminmerOverlapMean, sizeof(_kminmerOverlapMean));
		//gzread(file_parameters, (char*)&_kminmerSizePrev, sizeof(_kminmerSizePrev));
		gzclose(file_parameters);


		cout << "Loading sequences" << endl;
		loadReferences();
		cout << "Nb reference kminmers: " << _kminmer_to_referenceName.size() << " " << _kminmer_to_referenceIndex.size() << endl;

		cout << "Loading assembly graph" << endl;
		createAssemblyGraphFile();
		
		cout << "Coloring graph" << endl;
		indexAssemblyGraphUnitig();

		cout << "Computing reference positions" << endl;
		extractReferencePosition();

		cout << "Output mapped graph" << endl;
		outputMappedGraph(_outputDir + "/assembly_graph.gfa", _outputDir + "/assembly_graph_reference.gfa");

		/*
		generateAssemblyGraph();

		if(_generateContigPath || _generateReadPath){
			indexAssemblyGraphUnitig();
			if(_generateContigPath) generateContigPath();
			if(_generateReadPath) generateReadPath();
		}
		
		cerr << endl;
		cerr << "Assembly graph: " << _finalFilename << endl;
		if(_generateContigPath) cerr << "Contig path: " << _contigPathFilename << endl;
		if(_generateReadPath) cerr << "Read path: " << _readPathFilename << endl;
		cerr << "Done!" << endl;
		*/

		//closeLogFile();


	}

	unordered_map<KmerVec, vector<u_int32_t>> _kminmer_to_referenceIndex;
	unordered_map<KmerVec, vector<string>> _kminmer_to_referenceName;

	void loadReferences(){

		cout << _kminmerSize << " " << _minimizerSize << " " << _minimizerDensity << endl;
		ReadParserParallel readParser(_contigFilename, true, false, 1);
		readParser.parse(ReadSelectionFunctor(*this, _minimizerSize, _minimizerDensity));

	}

	class ReadSelectionFunctor {

		public:

		MappingContigToGraph& _readSelection;
		size_t _minimizerSize;
		float _minimizerDensity;
		MinimizerParser* _minimizerParser;
		EncoderRLE _encoderRLE;

		ReadSelectionFunctor(MappingContigToGraph& readSelection, size_t minimizerSize, float minimizerDensity) : _readSelection(readSelection){
			_minimizerSize = minimizerSize;
			_minimizerDensity = minimizerDensity;
			_minimizerParser = new MinimizerParser(minimizerSize, minimizerDensity);
		}

		ReadSelectionFunctor(const ReadSelectionFunctor& copy) : _readSelection(copy._readSelection){
			_minimizerSize = copy._minimizerSize;
			_minimizerDensity = copy._minimizerDensity;
			_minimizerParser = new MinimizerParser(_minimizerSize, _minimizerDensity);
		}

		~ReadSelectionFunctor(){
			delete _minimizerParser;
		}

		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;
			if(readIndex % 100000 == 0) Logger::get().debug() << readIndex;

			string rleSequence;
			vector<u_int64_t> rlePositions;
			_encoderRLE.execute(read._seq.c_str(), read._seq.size(), rleSequence, rlePositions, _readSelection._useHomopolymerCompression);


			vector<MinimizerType> minimizers;
			vector<u_int32_t> minimizers_pos;
			vector<u_int8_t> minimizers_direction;
			_minimizerParser->parse(rleSequence, minimizers, minimizers_pos, minimizers_direction);

			vector<KmerVec> kminmers; 
			vector<ReadKminmer> kminmersInfo;
			MDBG::getKminmers(_minimizerSize, _readSelection._kminmerSize, minimizers, minimizers_pos, kminmers, kminmersInfo, rlePositions, readIndex, false);

			for(const KmerVec& vec : kminmers){

				_readSelection._kminmer_to_referenceIndex[vec].push_back(readIndex);

				//if(read._seq.size() > 100000){
					_readSelection._kminmer_to_referenceName[vec].push_back(read._header);
				//}

			}


		}
	};

	void extractReferencePosition(){


		ReadParserParallel readParser(_contigFilename, true, false, 1);
		readParser.parse(ReferencePositionFunctor(*this, _minimizerSize, _minimizerDensity));


		_positionFile = ofstream(_outputDir + "/positionColor.csv");
		_positionFile << "Name,Position" << endl;

		for(const auto& it : _unitigIndex_to_refPosition){

			u_int32_t unitigIndex = it.first;
			const vector<RefPosition>& refPositions = it.second;

			string line = "";
			for(const RefPosition& refPosition : refPositions){
				line += to_string(refPosition._readIndex)+"-"+to_string(refPosition._position) + " ";
			}

			_positionFile << "utg" << unitigIndex << "," << line << endl;
		}
		
		_positionFile.close();
	}

	struct RefPosition{
		u_int32_t _readIndex;
		u_int32_t _position;
	};

	unordered_map<u_int32_t, vector<RefPosition>> _unitigIndex_to_refPosition;

	class ReferencePositionFunctor {

		public:

		MappingContigToGraph& _readSelection;
		size_t _minimizerSize;
		float _minimizerDensity;
		MinimizerParser* _minimizerParser;
		EncoderRLE _encoderRLE;

		ReferencePositionFunctor(MappingContigToGraph& readSelection, size_t minimizerSize, float minimizerDensity) : _readSelection(readSelection){
			_minimizerSize = minimizerSize;
			_minimizerDensity = minimizerDensity;
			_minimizerParser = new MinimizerParser(minimizerSize, minimizerDensity);
		}

		ReferencePositionFunctor(const ReferencePositionFunctor& copy) : _readSelection(copy._readSelection){
			_minimizerSize = copy._minimizerSize;
			_minimizerDensity = copy._minimizerDensity;
			_minimizerParser = new MinimizerParser(_minimizerSize, _minimizerDensity);
		}

		~ReferencePositionFunctor(){
			delete _minimizerParser;
		}

		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;

			string rleSequence;
			vector<u_int64_t> rlePositions;
			_encoderRLE.execute(read._seq.c_str(), read._seq.size(), rleSequence, rlePositions, _readSelection._useHomopolymerCompression);


			vector<MinimizerType> minimizers;
			vector<u_int32_t> minimizers_pos;
			vector<u_int8_t> minimizers_direction;
			_minimizerParser->parse(rleSequence, minimizers, minimizers_pos, minimizers_direction);

			vector<KmerVec> kminmers; 
			vector<ReadKminmer> kminmersInfo;
			MDBG::getKminmers(_minimizerSize, _readSelection._kminmerSize, minimizers, minimizers_pos, kminmers, kminmersInfo, rlePositions, readIndex, false);

			u_int32_t unitigPosition = 0;
			u_int32_t prevUnitigIndex = -1;

			for(u_int32_t i=0; i<kminmers.size(); i++){
				
				const KmerVec& vec = kminmers[i];

				if(_readSelection._kminmer_to_unitigIndex.find(vec) == _readSelection._kminmer_to_unitigIndex.end()) continue;

				u_int32_t unitigIndex = _readSelection._kminmer_to_unitigIndex[vec];

				if(unitigIndex != prevUnitigIndex){
					prevUnitigIndex = unitigIndex;
					_readSelection._unitigIndex_to_refPosition[unitigIndex].push_back({readIndex, unitigPosition});
					unitigPosition += 1;
				}

			}


		}
	};

	size_t _minimizerSize;
	size_t _kminmerSize;
	float _minimizerDensity;

	void generateAssemblyGraph(){

		/*
		cerr << "Generating unitig sequences..." << endl;
		createUnitigSequences();

		cerr << "Loading unitig sequences..." << endl;
		loadUnitigs();
		//loadUnitigIndex();
		
		cerr << "Creating assembly graph file..." << endl;
		createAssemblyGraphFile();
		*/
	}

	




	unordered_map<KmerVec, u_int32_t> _kminmer_to_unitigIndex;
	ofstream _positionFile;
	ofstream _colorFile;
	ofstream _nameFile;
	unordered_set<u_int32_t> _isUnitigWritten;
	unordered_set<string> _selectedGfaNodes;

	void indexAssemblyGraphUnitig(){

		cout << "Loading graph" << endl;
		loadGraph(_outputDir + "/assembly_graph.gfa");
		cout << "nb nodes: " << _successors.size() << endl;
		cout << "done" << endl;

		_colorFile = ofstream(_outputDir + "/contigColor.csv");
		_colorFile << "Name,Color" << endl;

		_nameFile = ofstream(_outputDir + "/contigName.csv");
		_nameFile << "Name,Text" << endl;

		KminmerParserParallel parser(_outputDir + "/assembly_graph.gfa.unitigs", _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(IndexAssemblyGraphUnitigFunctor(*this));

		_colorFile.close();
		_nameFile.close();
	}

	class IndexAssemblyGraphUnitigFunctor {

		public:

		MappingContigToGraph& _parent;

		IndexAssemblyGraphUnitigFunctor(MappingContigToGraph& parent) : _parent(parent){
		}

		IndexAssemblyGraphUnitigFunctor(const IndexAssemblyGraphUnitigFunctor& copy) : _parent(copy._parent){
		}

		~IndexAssemblyGraphUnitigFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			//cout << kminmerList._readIndex << " " << kminmerList._kminmersInfo.size() << endl;
			//getchar();
		


			for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
				
				//_logFile << readIndex << " " << i << endl;
				const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

				KmerVec vec = kminmerInfo._vec;

				bool orientation = !kminmerInfo._isReversed;

				//cout << _parent._kminmer_to_referenceIndex.size() << " " << vec._kmers.size() << " " << vec._kmers[0] << endl;
				//cout << i << " " << (_parent._kminmer_to_referenceIndex.find(vec) == _parent._kminmer_to_referenceIndex.end()) << endl;
				if(_parent._kminmer_to_referenceIndex.find(vec) == _parent._kminmer_to_referenceIndex.end()) continue;
			
				#pragma omp critical
				{

				_parent._kminmer_to_unitigIndex[vec] = _parent._unitigOrderRev[kminmerList._readIndex];
				
				for(u_int32_t referenceIndex: _parent._kminmer_to_referenceIndex[vec]){

					if(_parent._isUnitigWritten.find(_parent._unitigOrderRev[kminmerList._readIndex]) == _parent._isUnitigWritten.end()){
						_parent._isUnitigWritten.insert(_parent._unitigOrderRev[kminmerList._readIndex]);
						_parent._colorFile << "utg" << _parent._unitigOrderRev[kminmerList._readIndex] << ",green" << endl;

						string s = "";
						for(const string& referenceName : _parent._kminmer_to_referenceName[vec]){
							s += referenceName + " ";
						}

						_parent._nameFile << "utg" << _parent._unitigOrderRev[kminmerList._readIndex] << "," << s << endl;

						string nodeForward = "utg" + to_string(_parent._unitigOrderRev[kminmerList._readIndex]) + "+";
						string nodeReverse = "utg" + to_string(_parent._unitigOrderRev[kminmerList._readIndex]) + "-";
						/*
						if(_parent._successors.find(nodeForward) != _parent._successors.end()){
							for(const string& successorName : _parent._successors[nodeForward]){
								string unitigName = successorName;
								unitigName.pop_back();
								_parent._colorFile << unitigName << ",red" << endl;
							}
						}
						if(_parent._successors.find(nodeReverse) != _parent._successors.end()){
							for(const string& successorName : _parent._successors[nodeReverse]){
								string unitigName = successorName;
								unitigName.pop_back();
								_parent._colorFile << unitigName << ",red" << endl;
							}
						}
						*/

						vector<string> neighborsForward;
						_parent.getNeighbors(nodeForward, 10000, 0.5, neighborsForward);
						//cout << nodeForward << endl;
						
						_parent._selectedGfaNodes.insert(nodeForward);
						for(const string& neighbor : neighborsForward){
							_parent._selectedGfaNodes.insert(neighbor);
							//cout << "\t" << neighbor << endl;
						}

						vector<string> neighborsReverse;
						_parent.getNeighbors(nodeReverse, 10000, 0.5, neighborsReverse);
						//cout << nodeForward << endl;
						
						_parent._selectedGfaNodes.insert(nodeReverse);
						for(const string& neighbor : neighborsReverse){
							_parent._selectedGfaNodes.insert(neighbor);
							//cout << "\t" << neighbor << endl;
						}
						//getchar();

						//cout << nodeForward << " " << (_parent._successors.find(nodeForward) != _parent._successors.end()) << endl;
						//string nodeReverse= to_string(_parent._unitigOrderRev[kminmerList._readIndex]) + "-";
						//for(const string& successor : _successors[])
					}
				}
				}

				//_parent._kmerVec_to_unitigIndex[vec] = kminmerList._readIndex;
				
			}
		}
	};

	void createAssemblyGraphFile(){


		u_int64_t unitgIndex = 0;
        ifstream infile(_outputDir + "/assembly_graph.gfa");

        std::string line;


        while (std::getline(infile, line)){
            
            const vector<string>& fields = Utils::split(line, '\t');
            
            //cout << (*fields)[0] << endl;



			if((fields)[0] == "S"){
				/*
				//cout << line << endl;
				//for(size_t i=0; i<(*fields).size(); i++){
				//	cout << i << ": " << (*fields)[i] << endl;
				//}
				//getchar();
				//cout << line << endl;
				//cout << _unitigSequences.size() << " " << unitgIndex << endl;
				DnaBitset* unitigBitset = _unitigSequences[unitgIndex]._seqBitset;
				char* unitigSequence = unitigBitset->to_string();
				string unitigSequenceStr = string(unitigSequence);


				string line = (*fields)[0] + "\t" + (*fields)[1] + "\t" + unitigSequenceStr + "\tLN:i:" + to_string(unitigSequenceStr.size()) + "\t" + (*fields)[4];
				string lineNoSeq = (*fields)[0] + "\t" + (*fields)[1] + "\t" + "*" + "\tLN:i:" + to_string(unitigSequenceStr.size()) + "\t" + (*fields)[4];
				//cout << line << endl;

				outputFile << line << endl;
				outputFileNoSeq << lineNoSeq << endl;

				free(unitigSequence);
				delete unitigBitset;


				*/

				string name = (fields)[1];
				//size_t pos = name.find("utg");
				name.erase(0, 3);
				u_int32_t utg = stoull(name);

				_unitigOrder[utg] = unitgIndex;
				_unitigOrderRev[unitgIndex] = utg;
				unitgIndex += 1;
				
				//cout << name << " " << utg<< endl;
			}

            
        }




	}


	phmap::parallel_flat_hash_map<u_int32_t, u_int32_t> _unitigOrder;
	phmap::parallel_flat_hash_map<u_int32_t, u_int32_t> _unitigOrderRev;
	phmap::parallel_flat_hash_map<u_int32_t, string> _unitigIndex_to_contigName;

	unordered_map<string, vector<string>> _successors;
	unordered_map<string, u_int32_t> _nodeLength;
	unordered_map<string, u_int32_t> _nodeAbundance;

	struct NodeDepth{
		string _nodeName;
		u_int32_t _length;
	};

	void getNeighbors(const string& nodeName, u_int64_t maxLength, float abundanceCutoffFraction, vector<string>& neighbors){

		neighbors.clear();
		unordered_set<string> isVisited;

		queue<NodeDepth> queue;
		queue.push({nodeName, 0});
		isVisited.insert(nodeName);


		string sourceNameSimple = nodeName;
		sourceNameSimple.pop_back();
		float minAbundance = _nodeAbundance[sourceNameSimple] * abundanceCutoffFraction;
		//cout << "Min abundance: " << sourceNameSimple << " "  << _nodeAbundance[sourceNameSimple]  << " " << minAbundance << endl;
		while (!queue.empty()) {
			
			const NodeDepth currentNode = queue.front();
			queue.pop();
			
			if(currentNode._length > maxLength) continue;
			if(_successors.find(currentNode._nodeName) == _successors.end()) continue;


			for(const string successorName : _successors[currentNode._nodeName]) {
				if(isVisited.find(successorName) != isVisited.end()) continue;

				string successorNameSimple = successorName;
				successorNameSimple.pop_back();

				if(_nodeAbundance[successorNameSimple] <= 2) continue;
				if(_nodeAbundance[successorNameSimple] < minAbundance) continue;

				//if(isCorrected[readIndexNeighbor]) continue;

				isVisited.insert(successorName);
				queue.push({successorName, currentNode._length+_nodeLength[successorNameSimple]});
				neighbors.push_back(successorName);
			}
			
		}

	}


	void loadGraph(const string& filename){


        ifstream infile(filename);

        std::string line;
        //u_int64_t unitig_id = 0;

        //u_int32_t nbNodes = 0;

        //while (std::getline(infile, line)){
        //    if(line[0] == 'S') nbNodes += 1;
        //}

        //UnitigGraph* graph = new UnitigGraph(nbNodes);

        //infile.clear();
        //infile.seekg(0, std::ios::beg);


        while (std::getline(infile, line)){
            
            const vector<string>& fields = Utils::split(line, '\t');
            
            //cout << (*fields)[0] << endl;

            if((fields)[0] == "S"){
                
                size_t i=0;
                for(const string& field : (fields)){
                    if(i> 2){
                        //cout << field << endl;
                        const vector<string>& fields_optional = Utils::split(field, ':');
                        if((fields_optional)[0] == "LN"){
                            const string& unitig_name = (fields)[1];
                            u_int64_t unitig_length = std::stoull((fields_optional)[2]);

							_nodeLength[unitig_name] = unitig_length;

                        }
						else if((fields_optional)[0] == "dp"){
                            const string& unitig_name = (fields)[1];
                            u_int64_t unitig_abundance = std::stoull((fields_optional)[2]);

							_nodeAbundance[unitig_name] = unitig_abundance;

                        }
                    }
                    i += 1;
                }

                //unitig_id += 1;
            }
            else if((fields)[0] == "L"){

                const string& from = (fields)[1];
				const string& fromOrient = (fields)[2];
                //bool fromOrient = (*fields)[2] == "+";
                const string& to = (fields)[3];
				const string& toOrient = (fields)[4];
                //bool toOrient = (*fields)[4] == "+";
                u_int64_t overlap = std::stoull((fields)[5]);

                //u_int32_t from_id = unitigName_to_id(from);
                //u_int32_t to_id = unitigName_to_id(to);

                //graph->addEdge(from_id, fromOrient, to_id, toOrient, 0);

				string n1 = from + fromOrient;
				string n2 = to + toOrient;

				string n1_rev = from;
				if(fromOrient == "+"){
					n1_rev += "-";
				}
				else{
					n1_rev += "+";
				}

				string n2_rev = to;
				if(toOrient == "+"){
					n2_rev += "-";
				}
				else{
					n2_rev += "+";
				}

				_successors[n1].push_back(n2);
				_successors[n2_rev].push_back(n1_rev);


            }
            //else if((*fields)[0] == "A"){

                
                //cout << line << endl;

                //string unitig_name = (*fields)[1];
                //string node = (*fields)[4];

                //if(151064 == std::stoull(node.c_str())){
                //    cout << "lala" << endl;
                //    cout << unitig_name << " " << unitigName_to_id(unitig_name) << endl;
                //}
                //if(unitigName_to_id(unitig_name) == 0){
                //    cout << unitig_name << " " << node << endl;
                //}
                //cout << unitig_name << endl;

                //cout << unitig_name << endl;
                //cout << node << " " << unitig_name << endl;
                //node_to_unitig[std::stoull(node.c_str())] = unitigName_to_id(unitig_name);

                //counts[unitigName_to_id(unitig_name)] += 1;
                //cout << counts[unitigName_to_id(unitig_name)] << endl;
                //cout << line << endl;
                //cout << std::stoull(node.c_str()) << " " << std::stoull(unitig_name) << endl;
            //}

            //cout << line.substr(start, end - start) << endl;
            
        }





        //return graph;


	}

	void outputMappedGraph(const string& inputFilename, const string& outputFilename){


        ofstream outfile(outputFilename);
        ifstream infile(inputFilename);

        std::string line;
        vector<string>* fields = new vector<string>();
        vector<string>* fields_optional = new vector<string>();
        //u_int64_t unitig_id = 0;

        //u_int32_t nbNodes = 0;

        //while (std::getline(infile, line)){
        //    if(line[0] == 'S') nbNodes += 1;
        //}

        //UnitigGraph* graph = new UnitigGraph(nbNodes);

        //infile.clear();
        //infile.seekg(0, std::ios::beg);


        while (std::getline(infile, line)){
            
            const vector<string>& fields = Utils::split(line, '\t');
            
            //cout << (*fields)[0] << endl;

            if((fields)[0] == "S"){
                
                const string& nodeName = (fields)[1];

				string nodeNamForward = nodeName + "+";	
				string nodeNamReverse = nodeName + "-";
				if(_selectedGfaNodes.find(nodeNamForward) != _selectedGfaNodes.end()){
					outfile << line << endl;
				}
				else if(_selectedGfaNodes.find(nodeNamReverse) != _selectedGfaNodes.end()){
					outfile << line << endl;
				}

            }
            else if((fields)[0] == "L"){

                const string& from = (fields)[1];
				const string& fromOrient = (fields)[2];
                //bool fromOrient = (*fields)[2] == "+";
                const string& to = (fields)[3];
				const string& toOrient = (fields)[4];
                //bool toOrient = (*fields)[4] == "+";
                u_int64_t overlap = std::stoull((fields)[5]);

                //u_int32_t from_id = unitigName_to_id(from);
                //u_int32_t to_id = unitigName_to_id(to);

                //graph->addEdge(from_id, fromOrient, to_id, toOrient, 0);

				string n1 = from + fromOrient;
				string n2 = to + toOrient;

				string n1_rev = from;
				if(fromOrient == "+"){
					n1_rev += "-";
				}
				else{
					n1_rev += "+";
				}

				string n2_rev = to;
				if(toOrient == "+"){
					n2_rev += "-";
				}
				else{
					n2_rev += "+";
				}

				if(_selectedGfaNodes.find(n1) != _selectedGfaNodes.end() && _selectedGfaNodes.find(n2) != _selectedGfaNodes.end()){
					outfile << line << endl;
				}
				else if(_selectedGfaNodes.find(n1_rev) != _selectedGfaNodes.end() && _selectedGfaNodes.find(n2_rev) != _selectedGfaNodes.end()){
					outfile << line << endl;
				}


            }

            
        }



		outfile.close();

        //return graph;


	}



};	

#endif 


