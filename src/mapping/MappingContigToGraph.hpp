
#ifndef MDBG_METAG_MappingContigToGraph
#define MDBG_METAG_MappingContigToGraph

#include "../Commons.hpp"


class MappingContigToGraph : public Tool{
    
public:


	string _outputDir;
	size_t _k;
	int _nbCores;
	bool _generateContigPath;
	bool _generateReadPath;
	string _contigFilename;
	string _contigDataFilename;
	bool _useHomopolymerCompression;

	string _filename_exe;
	string _tmpDir;

	MappingContigToGraph(): Tool (){

	}


	void parseArgs(int argc, char* argv[]){


		_filename_exe = argv[0];

		args::ArgumentParser parser("gfa", ""); //"This is a test program.", "This goes after the options."
		//args::Positional<std::string> arg_contigs(parser, "contigs", "Contig file generated by metaMDBG", args::Options::Required);
		args::Positional<std::string> arg_outputDir(parser, "assemblyDir", "Output dir of a metaMDBG run", args::Options::Required);
		//args::Positional<int> arg_k(parser, "k", "Generate assembly graph for this k-min-mer size value (set to 0 to display available k values and corresponding length in bps)", args::Options::Required);
		args::Positional<std::string> arg_contigFilename(parser, "contigFilename", "Contigs to map", args::Options::Required);
		//args::Positional<std::string> arg_contigDataFilename(parser, "contigDataFilename", "contig_data.txt", args::Options::Required);
		//args::Flag arg_contigpath(parser, "", "Generate path of contigs in the assembly graph", {"contigpath"});
		//args::Flag arg_readpath(parser, "", "Generate path of reads in the assembly graph", {"readpath"});
		args::Flag arg_homopolymerCompression(parser, "", "Activate homopolymer compression", {ARG_HOMOPOLYMER_COMPRESSION});
		args::ValueFlag<int> arg_nbCores(parser, "", "Number of cores", {ARG_NB_CORES2}, NB_CORES_DEFAULT_INT);
		args::Flag arg_help(parser, "", "", {'h', "help"}, args::Options::Hidden);



		try
		{
			parser.ParseCLI(argc, argv);
		}
		catch (const args::Help&)
		{
			cerr << parser;
			exit(0);
		}
		catch (const std::exception& e)
		{
			cerr << parser;
			//_logFile << endl;
			cerr << e.what() << endl;
			exit(0);
		}

		if(arg_help){
			cerr << parser;
			exit(0);
		}



		_outputDir = args::get(arg_outputDir);
		_contigFilename  = args::get(arg_contigFilename);
		_nbCores = args::get(arg_nbCores);

		_useHomopolymerCompression = false;
		if(arg_homopolymerCompression){
			_useHomopolymerCompression = true;
		}

		cout << "Be careful if hifi: activate HPC" << endl;

		if(!fs::exists(_outputDir)){
			cerr << "Assembly dir does not exists" << endl;
			exit(1);
		}

		//_tmpDir = _outputDir + "/tmp/";

		//if(!fs::exists(_tmpDir)){
		//	cerr << "Invalid assembly dir" << endl;
		//	exit(1);
		//}

		openLogFile(_tmpDir);

		cout << "Assembly dir: " << _outputDir << endl;

	}


    void execute (){

		string filename_parameters = _outputDir + "/parameters.gz";
		gzFile file_parameters = gzopen(filename_parameters.c_str(),"rb");
		gzread(file_parameters, (char*)&_minimizerSize, sizeof(_minimizerSize));
		gzread(file_parameters, (char*)&_kminmerSize, sizeof(_kminmerSize));
		gzread(file_parameters, (char*)&_minimizerDensity, sizeof(_minimizerDensity));
		//gzread(file_parameters, (char*)&_kminmerSizeFirst, sizeof(_kminmerSizeFirst));
		//gzread(file_parameters, (char*)&_minimizerSpacingMean, sizeof(_minimizerSpacingMean));
		//gzread(file_parameters, (char*)&_kminmerLengthMean, sizeof(_kminmerLengthMean));
		//gzread(file_parameters, (char*)&_kminmerOverlapMean, sizeof(_kminmerOverlapMean));
		//gzread(file_parameters, (char*)&_kminmerSizePrev, sizeof(_kminmerSizePrev));
		gzclose(file_parameters);


		cout << "Loading sequences" << endl;
		loadReferences();
		cout << "Nb reference kminmers: " << _kminmer_to_referenceName.size() << " " << _kminmer_to_referenceIndex.size() << endl;

		cout << "Loading assembly graph" << endl;
		createAssemblyGraphFile();
		
		cout << "Coloring graph" << endl;
		indexAssemblyGraphUnitig();

		cout << "Computing reference positions" << endl;
		extractReferencePosition();
		/*
		generateAssemblyGraph();

		if(_generateContigPath || _generateReadPath){
			indexAssemblyGraphUnitig();
			if(_generateContigPath) generateContigPath();
			if(_generateReadPath) generateReadPath();
		}
		
		cerr << endl;
		cerr << "Assembly graph: " << _finalFilename << endl;
		if(_generateContigPath) cerr << "Contig path: " << _contigPathFilename << endl;
		if(_generateReadPath) cerr << "Read path: " << _readPathFilename << endl;
		cerr << "Done!" << endl;
		*/

		//closeLogFile();


	}

	unordered_map<KmerVec, vector<u_int32_t>> _kminmer_to_referenceIndex;
	unordered_map<KmerVec, vector<string>> _kminmer_to_referenceName;

	void loadReferences(){

		cout << _kminmerSize << " " << _minimizerSize << " " << _minimizerDensity << endl;
		ReadParserParallel readParser(_contigFilename, true, false, 1);
		readParser.parse(ReadSelectionFunctor(*this, _minimizerSize, _minimizerDensity));

	}

	class ReadSelectionFunctor {

		public:

		MappingContigToGraph& _readSelection;
		size_t _minimizerSize;
		float _minimizerDensity;
		MinimizerParser* _minimizerParser;
		EncoderRLE _encoderRLE;

		ReadSelectionFunctor(MappingContigToGraph& readSelection, size_t minimizerSize, float minimizerDensity) : _readSelection(readSelection){
			_minimizerSize = minimizerSize;
			_minimizerDensity = minimizerDensity;
			_minimizerParser = new MinimizerParser(minimizerSize, minimizerDensity);
		}

		ReadSelectionFunctor(const ReadSelectionFunctor& copy) : _readSelection(copy._readSelection){
			_minimizerSize = copy._minimizerSize;
			_minimizerDensity = copy._minimizerDensity;
			_minimizerParser = new MinimizerParser(_minimizerSize, _minimizerDensity);
		}

		~ReadSelectionFunctor(){
			delete _minimizerParser;
		}

		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;
			if(readIndex % 100000 == 0) Logger::get().debug() << readIndex;

			string rleSequence;
			vector<u_int64_t> rlePositions;
			_encoderRLE.execute(read._seq.c_str(), read._seq.size(), rleSequence, rlePositions, _readSelection._useHomopolymerCompression);


			vector<MinimizerType> minimizers;
			vector<u_int32_t> minimizers_pos;
			vector<u_int8_t> minimizers_direction;
			_minimizerParser->parse(rleSequence, minimizers, minimizers_pos, minimizers_direction);

			vector<KmerVec> kminmers; 
			vector<ReadKminmer> kminmersInfo;
			MDBG::getKminmers(_minimizerSize, _readSelection._kminmerSize, minimizers, minimizers_pos, kminmers, kminmersInfo, rlePositions, readIndex, false);

			for(const KmerVec& vec : kminmers){

				_readSelection._kminmer_to_referenceIndex[vec].push_back(readIndex);

				//if(read._seq.size() > 100000){
					_readSelection._kminmer_to_referenceName[vec].push_back(read._header);
				//}

			}


		}
	};

	void extractReferencePosition(){


		ReadParserParallel readParser(_contigFilename, true, false, 1);
		readParser.parse(ReferencePositionFunctor(*this, _minimizerSize, _minimizerDensity));


		_positionFile = ofstream(_outputDir + "/positionColor.csv");
		_positionFile << "Name,Position" << endl;

		for(const auto& it : _unitigIndex_to_refPosition){

			u_int32_t unitigIndex = it.first;
			const vector<RefPosition>& refPositions = it.second;

			string line = "";
			for(const RefPosition& refPosition : refPositions){
				line += to_string(refPosition._readIndex)+"-"+to_string(refPosition._position) + " ";
			}

			_positionFile << "utg" << unitigIndex << "," << line << endl;
		}
		
		_positionFile.close();
	}

	struct RefPosition{
		u_int32_t _readIndex;
		u_int32_t _position;
	};

	unordered_map<u_int32_t, vector<RefPosition>> _unitigIndex_to_refPosition;

	class ReferencePositionFunctor {

		public:

		MappingContigToGraph& _readSelection;
		size_t _minimizerSize;
		float _minimizerDensity;
		MinimizerParser* _minimizerParser;
		EncoderRLE _encoderRLE;

		ReferencePositionFunctor(MappingContigToGraph& readSelection, size_t minimizerSize, float minimizerDensity) : _readSelection(readSelection){
			_minimizerSize = minimizerSize;
			_minimizerDensity = minimizerDensity;
			_minimizerParser = new MinimizerParser(minimizerSize, minimizerDensity);
		}

		ReferencePositionFunctor(const ReferencePositionFunctor& copy) : _readSelection(copy._readSelection){
			_minimizerSize = copy._minimizerSize;
			_minimizerDensity = copy._minimizerDensity;
			_minimizerParser = new MinimizerParser(_minimizerSize, _minimizerDensity);
		}

		~ReferencePositionFunctor(){
			delete _minimizerParser;
		}

		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;

			string rleSequence;
			vector<u_int64_t> rlePositions;
			_encoderRLE.execute(read._seq.c_str(), read._seq.size(), rleSequence, rlePositions, _readSelection._useHomopolymerCompression);


			vector<MinimizerType> minimizers;
			vector<u_int32_t> minimizers_pos;
			vector<u_int8_t> minimizers_direction;
			_minimizerParser->parse(rleSequence, minimizers, minimizers_pos, minimizers_direction);

			vector<KmerVec> kminmers; 
			vector<ReadKminmer> kminmersInfo;
			MDBG::getKminmers(_minimizerSize, _readSelection._kminmerSize, minimizers, minimizers_pos, kminmers, kminmersInfo, rlePositions, readIndex, false);

			u_int32_t unitigPosition = 0;
			u_int32_t prevUnitigIndex = -1;

			for(u_int32_t i=0; i<kminmers.size(); i++){
				
				const KmerVec& vec = kminmers[i];

				if(_readSelection._kminmer_to_unitigIndex.find(vec) == _readSelection._kminmer_to_unitigIndex.end()) continue;

				u_int32_t unitigIndex = _readSelection._kminmer_to_unitigIndex[vec];

				if(unitigIndex != prevUnitigIndex){
					prevUnitigIndex = unitigIndex;
					_readSelection._unitigIndex_to_refPosition[unitigIndex].push_back({readIndex, unitigPosition});
					unitigPosition += 1;
				}

			}


		}
	};

	size_t _minimizerSize;
	size_t _kminmerSize;
	float _minimizerDensity;

	void generateAssemblyGraph(){

		/*
		cerr << "Generating unitig sequences..." << endl;
		createUnitigSequences();

		cerr << "Loading unitig sequences..." << endl;
		loadUnitigs();
		//loadUnitigIndex();
		
		cerr << "Creating assembly graph file..." << endl;
		createAssemblyGraphFile();
		*/
	}

	




	unordered_map<KmerVec, u_int32_t> _kminmer_to_unitigIndex;
	ofstream _positionFile;
	ofstream _colorFile;
	ofstream _nameFile;
	unordered_set<u_int32_t> _isUnitigWritten;

	void indexAssemblyGraphUnitig(){


		_colorFile = ofstream(_outputDir + "/contigColor.csv");
		_colorFile << "Name,Color" << endl;

		_nameFile = ofstream(_outputDir + "/contigName.csv");
		_nameFile << "Name,Text" << endl;

		KminmerParserParallel parser(_outputDir + "/assembly_graph.gfa.unitigs", _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(IndexAssemblyGraphUnitigFunctor(*this));

		_colorFile.close();
		_nameFile.close();
	}

	class IndexAssemblyGraphUnitigFunctor {

		public:

		MappingContigToGraph& _parent;

		IndexAssemblyGraphUnitigFunctor(MappingContigToGraph& parent) : _parent(parent){
		}

		IndexAssemblyGraphUnitigFunctor(const IndexAssemblyGraphUnitigFunctor& copy) : _parent(copy._parent){
		}

		~IndexAssemblyGraphUnitigFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			//cout << kminmerList._readIndex << " " << kminmerList._kminmersInfo.size() << endl;
			//getchar();
			
			#pragma omp critical
			{

				for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
					
					//_logFile << readIndex << " " << i << endl;
					const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

					KmerVec vec = kminmerInfo._vec;
					_parent._kminmer_to_unitigIndex[vec] = _parent._unitigOrderRev[kminmerList._readIndex];

					bool orientation = !kminmerInfo._isReversed;

					//cout << _parent._kminmer_to_referenceIndex.size() << " " << vec._kmers.size() << " " << vec._kmers[0] << endl;
					//cout << i << " " << (_parent._kminmer_to_referenceIndex.find(vec) == _parent._kminmer_to_referenceIndex.end()) << endl;
					if(_parent._kminmer_to_referenceIndex.find(vec) == _parent._kminmer_to_referenceIndex.end()) continue;

					cout << "lala" << endl;
					for(u_int32_t referenceIndex: _parent._kminmer_to_referenceIndex[vec]){

						if(_parent._isUnitigWritten.find(_parent._unitigOrderRev[kminmerList._readIndex]) == _parent._isUnitigWritten.end()){
							_parent._isUnitigWritten.insert(_parent._unitigOrderRev[kminmerList._readIndex]);
							_parent._colorFile << "utg" << _parent._unitigOrderRev[kminmerList._readIndex] << ",green" << endl;

							string s = "";
							for(const string& referenceName : _parent._kminmer_to_referenceName[vec]){
								s += referenceName + " ";
							}

							_parent._nameFile << "utg" << _parent._unitigOrderRev[kminmerList._readIndex] << "," << s << endl;
						}
					}

					//_parent._kmerVec_to_unitigIndex[vec] = kminmerList._readIndex;
				}
			}
		}
	};

	void createAssemblyGraphFile(){


		u_int64_t unitgIndex = 0;
        ifstream infile(_outputDir + "/assembly_graph.gfa");

        std::string line;
        vector<string>* fields = new vector<string>();
        vector<string>* fields_optional = new vector<string>();


        while (std::getline(infile, line)){
            
            GfaParser::tokenize(line, fields, '\t');
            
            //cout << (*fields)[0] << endl;



			if((*fields)[0] == "S"){
				/*
				//cout << line << endl;
				//for(size_t i=0; i<(*fields).size(); i++){
				//	cout << i << ": " << (*fields)[i] << endl;
				//}
				//getchar();
				//cout << line << endl;
				//cout << _unitigSequences.size() << " " << unitgIndex << endl;
				DnaBitset* unitigBitset = _unitigSequences[unitgIndex]._seqBitset;
				char* unitigSequence = unitigBitset->to_string();
				string unitigSequenceStr = string(unitigSequence);


				string line = (*fields)[0] + "\t" + (*fields)[1] + "\t" + unitigSequenceStr + "\tLN:i:" + to_string(unitigSequenceStr.size()) + "\t" + (*fields)[4];
				string lineNoSeq = (*fields)[0] + "\t" + (*fields)[1] + "\t" + "*" + "\tLN:i:" + to_string(unitigSequenceStr.size()) + "\t" + (*fields)[4];
				//cout << line << endl;

				outputFile << line << endl;
				outputFileNoSeq << lineNoSeq << endl;

				free(unitigSequence);
				delete unitigBitset;


				*/

				string name = (*fields)[1];
				//size_t pos = name.find("utg");
				name.erase(0, 3);
				u_int32_t utg = stoull(name);

				_unitigOrder[utg] = unitgIndex;
				_unitigOrderRev[unitgIndex] = utg;
				unitgIndex += 1;
				
				//cout << name << " " << utg<< endl;
			}

            
        }


        delete fields;
        delete fields_optional;



	}


	phmap::parallel_flat_hash_map<u_int32_t, u_int32_t> _unitigOrder;
	phmap::parallel_flat_hash_map<u_int32_t, u_int32_t> _unitigOrderRev;
	phmap::parallel_flat_hash_map<u_int32_t, string> _unitigIndex_to_contigName;

	/*
	//vector<u_int32_t> _unitigIndexes;
	struct UnitigSequence{
		DnaBitset* _seqBitset;
		u_int32_t _overlapSizePlus;
		u_int32_t _overlapSizeMinus;
	};
	vector<UnitigSequence> _unitigSequences;
	phmap::parallel_flat_hash_map<KmerVec, u_int32_t> _kmerVec_to_unitigIndex;

	void createUnitigSequences(){
		string readFilename = _tmpDir + "/input.txt";
		string command = _filename_exe + " toBasespace " + " " + _tmpDir + " " + _passDir + "/assembly_graph.gfa.unitigs " + " " + _unitigFilename + " " + readFilename  + " -t " + to_string(_nbCores);
		Utils::executeCommand(command, _tmpDir, _logFile);
	}


	void loadUnitigs(){
		

		ReadParserParallel readParser(_unitigFilename, true, false, 1, _logFile);
		readParser.parse(LoadUnitigsFunctor(*this));

	}

	class LoadUnitigsFunctor {

		public:

		GenerateGfa& _parent;
		MinimizerParser* _minimizerParser;
		EncoderRLE _encoderRLE;

		LoadUnitigsFunctor(GenerateGfa& parent) : _parent(parent){
			_minimizerParser = new MinimizerParser(_parent._minimizerSize, _parent._minimizerDensity);
			_minimizerParser->_trimBps = 0;
		}

		LoadUnitigsFunctor(const LoadUnitigsFunctor& copy) : _parent(copy._parent){
			_minimizerParser = new MinimizerParser(_parent._minimizerSize, _parent._minimizerDensity);
			_minimizerParser->_trimBps = 0;
		}

		~LoadUnitigsFunctor(){
			delete _minimizerParser;
		}


		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;

			string rleSequence;
			vector<u_int64_t> rlePositions;
			_encoderRLE.execute(read._seq.c_str(), read._seq.size(), rleSequence, rlePositions);


			vector<u_int64_t> minimizers;
			vector<u_int64_t> minimizers_pos;
			_minimizerParser->parse(rleSequence, minimizers, minimizers_pos);


			u_int32_t overlapSizePlus = 0;
			u_int32_t overlapSizeMinus = 0;

			if(minimizers.size() < _parent._kminmerSize){
				cout << read._header << endl;
				//cout << "lala " << minimizers.size() << " " << read._seq.size() << " " << rleSequence.size() << endl;

				
			}
			else{
				overlapSizePlus = read._seq.size() - rlePositions[minimizers_pos[minimizers.size()-_parent._kminmerSize+1]];
				overlapSizeMinus = rlePositions[minimizers_pos[_parent._kminmerSize-2]+_parent._minimizerSize];
			}
			//rlePositions[pos]; i<rlePositions[pos+_readSelection._minimizerSize]

			//cout << read._seq << " " << read._seq.size() << endl;
			
			//for(size_t i=0; i<minimizers.size(); i++){
			//	cout << i << ": " << rlePositions[minimizers_pos[i]] << endl;
			//}


			//cout << overlapSizeMinus << " " << overlapSizePlus << endl;
			//cout << readIndex << " " << minimizers.size() << endl;
			_parent._unitigSequences.push_back({new DnaBitset(read._seq), overlapSizePlus, overlapSizeMinus});

		}
		
	};





	void indexAssemblyGraphUnitig(){

		KminmerParserParallel parser(_passDir + "/assembly_graph.gfa.unitigs", _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(IndexAssemblyGraphUnitigFunctor(*this));
	}

	class IndexAssemblyGraphUnitigFunctor {

		public:

		GenerateGfa& _parent;

		IndexAssemblyGraphUnitigFunctor(GenerateGfa& parent) : _parent(parent){
		}

		IndexAssemblyGraphUnitigFunctor(const IndexAssemblyGraphUnitigFunctor& copy) : _parent(copy._parent){
		}

		~IndexAssemblyGraphUnitigFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			
			#pragma omp critical
			{

				for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
					
					//_logFile << readIndex << " " << i << endl;
					const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

					KmerVec vec = kminmerInfo._vec;

					bool orientation = !kminmerInfo._isReversed;

					_parent._kmerVec_to_unitigIndex[vec] = kminmerList._readIndex;
				}
			}
		}
	};
	
	unordered_set<u_int32_t> _validContigIndex;
	ofstream _contigPathFile;
	phmap::parallel_flat_hash_map<u_int32_t, string> _contigIndex_to_headers;

	void generateContigPath(){
		cerr << "Generating contig path..." << endl;

		const string& contigFilename = _outputDir + "/contigs.fasta.gz";
		if(!fs::exists(contigFilename)){
			cerr << "Can't find contig path at location: " + contigFilename << endl;
			cerr << "Skip contig path" << endl;
			return;
		}

		const string& contigDataFilename = _tmpDir + "/contig_data.txt";
		if(!fs::exists(contigDataFilename)){
			cerr << "Can't find contig data at location: " + contigDataFilename << endl;
			cerr << "Skip contig path" << endl;
		}


		_contigPathFile = ofstream(_contigPathFilename);

		ReadParserParallel readParser(contigFilename, true, false, 1, _logFile);
		readParser.parse(LoadContigIndexFunctor(*this));

		KminmerParserParallel parser(contigDataFilename, _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(GenerateContigPathFunctor(*this));

		_validContigIndex.clear();
		_contigIndex_to_headers.clear();
		_contigPathFile.close();
	}

	class LoadContigIndexFunctor {

		public:

		GenerateGfa& _parent;

		LoadContigIndexFunctor(GenerateGfa& parent) : _parent(parent){
		}

		LoadContigIndexFunctor(const LoadContigIndexFunctor& copy) : _parent(copy._parent){
		}

		~LoadContigIndexFunctor(){
		}


		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;
			
			//cout << read._header << endl;
			u_int32_t contigIndex = Utils::contigName_to_contigIndex(read._header);
			//cout << contigIndex << endl;

			_parent._validContigIndex.insert(contigIndex);
			_parent._contigIndex_to_headers[contigIndex] = read._header;
		}

	};

	class GenerateContigPathFunctor {

		public:

		GenerateGfa& _parent;

		GenerateContigPathFunctor(GenerateGfa& parent) : _parent(parent){
		}

		GenerateContigPathFunctor(const GenerateContigPathFunctor& copy) : _parent(copy._parent){
		}

		~GenerateContigPathFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			
			u_int32_t contigIndex = kminmerList._readIndex;
			if(_parent._validContigIndex.find(contigIndex) == _parent._validContigIndex.end()) return;

			u_int32_t _prevUnitigIndex = -1;
			vector<u_int32_t> path;

			for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
				
				//_logFile << readIndex << " " << i << endl;
				const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

				KmerVec vec = kminmerInfo._vec;

				bool orientation = !kminmerInfo._isReversed;

				if(_parent._kmerVec_to_unitigIndex.find(vec) == _parent._kmerVec_to_unitigIndex.end()){
					//cout << "can't find kmerVec ???" << endl;
					continue;
				}

				u_int32_t unitigIndex = _parent._kmerVec_to_unitigIndex[vec];

				if(unitigIndex != _prevUnitigIndex){
					_prevUnitigIndex = unitigIndex;
					//cout << unitigIndex << endl;
					path.push_back(unitigIndex);
				}
				//_toBasespace._kmerVecIndex[vec].push_back({(u_int32_t) kminmerList._readIndex, (u_int32_t) i});
			}

			#pragma omp critical
			{

				_parent._contigPathFile << _parent._contigIndex_to_headers[contigIndex];
				for(u_int32_t unitigIndex : path){
					_parent._contigPathFile << "\tutg" << _parent._unitigOrderRev[unitigIndex];
				}
				_parent._contigPathFile << endl;

			}
		}
	};


	ofstream _readPathFile;

	void generateReadPath(){
		cerr << "Generating read path..." << endl;

		const string& readDataFilename = _tmpDir + "/read_data.txt";
		if(!fs::exists(readDataFilename)){
			cerr << "Can't find read data at location: " + readDataFilename << endl;
			cerr << "Skip read path" << endl;
		}

		_readPathFile = ofstream(_readPathFilename);

		KminmerParserParallel parser(readDataFilename, _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(GenerateReadPathFunctor(*this));

		_readPathFile.close();
	}

	class GenerateReadPathFunctor {

		public:

		GenerateGfa& _parent;

		GenerateReadPathFunctor(GenerateGfa& parent) : _parent(parent){
		}

		GenerateReadPathFunctor(const GenerateReadPathFunctor& copy) : _parent(copy._parent){
		}

		~GenerateReadPathFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			
			u_int32_t readIndex = kminmerList._readIndex;

			u_int32_t _prevUnitigIndex = -1;
			vector<u_int32_t> path;

			for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
				
				//_logFile << readIndex << " " << i << endl;
				const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

				KmerVec vec = kminmerInfo._vec;

				bool orientation = !kminmerInfo._isReversed;

				if(_parent._kmerVec_to_unitigIndex.find(vec) == _parent._kmerVec_to_unitigIndex.end()){
					//cout << "can't find kmerVec ???" << endl;
					continue;
				}

				u_int32_t unitigIndex = _parent._kmerVec_to_unitigIndex[vec];

				if(unitigIndex != _prevUnitigIndex){
					_prevUnitigIndex = unitigIndex;
					//cout << unitigIndex << endl;
					path.push_back(unitigIndex);
				}
				//_toBasespace._kmerVecIndex[vec].push_back({(u_int32_t) kminmerList._readIndex, (u_int32_t) i});
			}

			#pragma omp critical
			{



				_parent._readPathFile << "r" << readIndex;
				for(u_int32_t unitigIndex : path){
					_parent._readPathFile << "\tutg" << _parent._unitigOrderRev[unitigIndex];
				}
				_parent._readPathFile << endl;

			}
		}
	};
	*/

};	

#endif 


