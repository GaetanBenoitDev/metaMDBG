
#ifndef MDBG_METAG_GENERATEGFA
#define MDBG_METAG_GENERATEGFA

#include "../Commons.hpp"


class GenerateGfa : public Tool{
    
public:


	string _outputDir;
	size_t _k;
	int _nbCores;
	bool _generateContigPath;
	bool _generateReadPath;
	bool _useHomopolymerCompression;
	int _dataType;

	string _filename_exe;
	string _tmpDir;

	GenerateGfa(): Tool (){

	}


	void parseArgs(int argc, char* argv[]){


		_filename_exe = argv[0];

		args::ArgumentParser parser("gfa", ""); //"This is a test program.", "This goes after the options."
		args::Group groupInputOutput(parser, "Basic options:");
		//args::Positional<std::string> arg_contigs(parser, "contigs", "Contig file generated by metaMDBG", args::Options::Required);
		args::ValueFlag<std::string> arg_outputDir(groupInputOutput, "", "Output dir of a metaMDBG run", {"assembly-dir"});
		args::ValueFlag<int> arg_k(groupInputOutput, "", "Generate assembly graph for this k value (set to 0 to display available k values)", {"k"});
		args::Flag arg_contigpath(groupInputOutput, "", "Generate path of contigs in the assembly graph", {"contigpath"});
		args::Flag arg_readpath(groupInputOutput, "", "Generate path of reads in the assembly graph", {"readpath"});
		args::ValueFlag<int> arg_nbCores(groupInputOutput, "", "Number of cores", {ARG_NB_CORES2}, NB_CORES_DEFAULT_INT);
		args::Flag arg_help(groupInputOutput, "", "", {'h', "help"}, args::Options::Hidden);




		try
		{
			parser.ParseCLI(argc, argv);
		}
		catch (const args::Help&)
		{
			cerr << parser;
			exit(0);
		}
		catch (const std::exception& e)
		{
			cerr << parser;
			//_logFile << endl;
			cerr << e.what() << endl;
			exit(0);
		}

		if(arg_help){
			cerr << parser;
			exit(0);
		}



		if(!arg_outputDir){
			std::cerr << parser;
			cerr << " Argument --assembly-dir is required" << endl;
			exit(0);
		}

		if(!arg_k){
			std::cerr << parser;
			cerr << " Argument --k is required" << endl;
			exit(0);
		}

		_outputDir = args::get(arg_outputDir);
		_k = args::get(arg_k);
		_nbCores = args::get(arg_nbCores);

		_generateContigPath = false;
		if(arg_contigpath){
			_generateContigPath = true;
		}

		_generateReadPath = false;
		if(arg_readpath){
			_generateReadPath = true;
		}

		if(!fs::exists(_outputDir)){
			Logger::get().error() << "ERROR: Assembly dir does not exists";
			exit(1);
		}

		_tmpDir = _outputDir + "/tmp/";

		if(!fs::exists(_tmpDir)){
			Logger::get().error() << "Error: Invalid assembly dir";
			exit(1);
		}

		openLogFile(_tmpDir);


	}


    void execute (){

		if(_k <= 0){
			displayAvailableK();
		}
		else{

			vector<size_t> kvalues = getAvailableKValues();
			if(std::find(kvalues.begin(), kvalues.end(), _k) == kvalues.end()){
				displayAvailableK();
				Logger::get().error() << "\nERROR: Invalid k value (choose one from the list above)";
				exit(1);
			}

			generateAssemblyGraph();

			if(_generateContigPath || _generateReadPath){
				indexAssemblyGraphUnitig();
				if(_generateContigPath) generateContigPath();
				if(_generateReadPath) generateReadPath();
			}
			
			Logger::get().info();
			Logger::get().info() << "Assembly graph: " << _finalFilename;
			if(_generateContigPath) Logger::get().info() << "Contig path: " << _contigPathFilename;
			if(_generateReadPath) Logger::get().info() << "Read path: " << _readPathFilename;
			Logger::get().info() << "Done!";

		}

		//closeLogFile();


	}

	void displayAvailableK(){

		vector<size_t> kvalues = getAvailableKValues();

		Logger::get().info() << "\nAvailable k value and corresponding length in bps:";

		for(size_t k : kvalues){

			string passDir = _tmpDir + "/pass_k" + to_string(k) + "/";

			string filename_parameters = passDir + "/parameters.gz";
			gzFile file_parameters = gzopen(filename_parameters.c_str(),"rb");
			gzread(file_parameters, (char*)&_minimizerSize, sizeof(_minimizerSize));
			gzread(file_parameters, (char*)&_kminmerSize, sizeof(_kminmerSize));
			gzread(file_parameters, (char*)&_minimizerDensity_assembly, sizeof(_minimizerDensity_assembly));
			gzread(file_parameters, (char*)&_kminmerSizeFirst, sizeof(_kminmerSizeFirst));
			gzread(file_parameters, (char*)&_minimizerSpacingMean, sizeof(_minimizerSpacingMean));
			gzread(file_parameters, (char*)&_kminmerLengthMean, sizeof(_kminmerLengthMean));
			gzread(file_parameters, (char*)&_kminmerOverlapMean, sizeof(_kminmerOverlapMean));
			gzread(file_parameters, (char*)&_kminmerSizePrev, sizeof(_kminmerSizePrev));
			gzread(file_parameters, (char*)&_kminmerSizeLast, sizeof(_kminmerSizeLast));
			gzread(file_parameters, (char*)&_meanReadLength, sizeof(_meanReadLength));
			gzread(file_parameters, (char*)&_minimizerDensity_correction, sizeof(_minimizerDensity_correction));
			gzread(file_parameters, (char*)&_useHomopolymerCompression, sizeof(_useHomopolymerCompression));
			gzread(file_parameters, (char*)&_dataType, sizeof(_dataType));
			gzclose(file_parameters);
			
			
			Logger::get().info() << "\t- " << k << " (" << kToKmerSize(_kminmerSize, _minimizerSize, _minimizerDensity_assembly) << " bps)";

		}
	}

	size_t kToKmerSize(size_t kminmerSize, size_t minimizerSize, float minimizerDensity){
		return 1/minimizerDensity * (kminmerSize-1) + minimizerSize;
	}

	vector<size_t> getAvailableKValues(){

		const string pattern = "pass_k";
		vector<size_t> kvalues;

		std::string path = _tmpDir + "/";
		for (const auto & entry : fs::directory_iterator(path)){
			if (!entry.is_directory()) continue;

			string path = entry.path();
			string filename = entry.path().filename();

			if (filename.find(pattern) == string::npos) continue;

			//cout << path << " " << filename << endl;

			filename.erase(0, pattern.size());
			size_t k = stoull(filename);

			//cout << path << " " << k << endl;
			kvalues.push_back(k);
		}

		std::sort(kvalues.begin(), kvalues.end());

		return kvalues;
	}

	string _passDir;
	string _unitigFilename;
	string _finalFilename;
	string _finalFilenameNoSeq;
	string _contigPathFilename;
	string _readPathFilename;

	float _minimizerDensity_assembly;
    size_t _minimizerSize;
    size_t _kminmerSize;		
	float _minimizerSpacingMean;
	float _kminmerLengthMean;
	float _kminmerOverlapMean;
	size_t _kminmerSizeFirst;
	size_t _kminmerSizePrev;
	size_t _kminmerSizeLast;
	size_t _meanReadLength;
	float _minimizerDensity_correction;
	float _minReadQuality;
	float _minIdentity;
	float _minOverlapLength;

	void generateAssemblyGraph(){


		_passDir = _tmpDir + "/pass_k" + to_string(_k) + "/";
		_unitigFilename = _passDir + "/unitigs.fasta.gz";

		string filename_parameters = _passDir + "/parameters.gz";
		gzFile file_parameters = gzopen(filename_parameters.c_str(),"rb");
		gzread(file_parameters, (char*)&_minimizerSize, sizeof(_minimizerSize));
		gzread(file_parameters, (char*)&_kminmerSize, sizeof(_kminmerSize));
		gzread(file_parameters, (char*)&_minimizerDensity_assembly, sizeof(_minimizerDensity_assembly));
		gzread(file_parameters, (char*)&_kminmerSizeFirst, sizeof(_kminmerSizeFirst));
		gzread(file_parameters, (char*)&_minimizerSpacingMean, sizeof(_minimizerSpacingMean));
		gzread(file_parameters, (char*)&_kminmerLengthMean, sizeof(_kminmerLengthMean));
		gzread(file_parameters, (char*)&_kminmerOverlapMean, sizeof(_kminmerOverlapMean));
		gzread(file_parameters, (char*)&_kminmerSizePrev, sizeof(_kminmerSizePrev));
		gzread(file_parameters, (char*)&_kminmerSizeLast, sizeof(_kminmerSizeLast));
		gzread(file_parameters, (char*)&_meanReadLength, sizeof(_meanReadLength));
		gzread(file_parameters, (char*)&_minimizerDensity_correction, sizeof(_minimizerDensity_correction));
		gzread(file_parameters, (char*)&_useHomopolymerCompression, sizeof(_useHomopolymerCompression));
		gzread(file_parameters, (char*)&_dataType, sizeof(_dataType));
		gzclose(file_parameters);

		_finalFilename = _outputDir + "/assemblyGraph_k" + to_string(_kminmerSize) + "_" + to_string(kToKmerSize(_kminmerSize, _minimizerSize, _minimizerDensity_assembly)) + "bps.gfa";
		_finalFilenameNoSeq = _outputDir + "/assemblyGraph_k" + to_string(_kminmerSize) + "_" + to_string(kToKmerSize(_kminmerSize, _minimizerSize, _minimizerDensity_assembly)) + "bps.noseq.gfa";
		_contigPathFilename = _outputDir + "/assemblyGraph_k" + to_string(_kminmerSize) + "_" + to_string(kToKmerSize(_kminmerSize, _minimizerSize, _minimizerDensity_assembly)) + "bps_contigpath.tsv";
		_readPathFilename = _outputDir + "/assemblyGraph_k" + to_string(_kminmerSize) + "_" + to_string(kToKmerSize(_kminmerSize, _minimizerSize, _minimizerDensity_assembly)) + "bps_readpath.tsv";

		Logger::get().info() << "";
		Logger::get().info() << "\tAssembly dir: " << _outputDir;
		Logger::get().info() << "\tUsed k: " << _k;
		//Logger::get().info() << "\tGenerating assembly graph for k value: " << _k << " (corresponding sequence length = " << kToKmerSize(_kminmerSize, _minimizerSize, _minimizerDensity_assembly) << " bps)";
		Logger::get().info() << "\tHomopolymer compression: " << _useHomopolymerCompression;
		Logger::get().info() << "\tData type: " << _dataType;
		Logger::get().info() << "";

		Logger::get().info() << "Generating unitig sequences";
		createUnitigSequences();

		Logger::get().info() << "Loading unitig sequences";
		loadUnitigs();
		//loadUnitigIndex();
		
		Logger::get().info() << "Creating assembly graph file";
		createAssemblyGraphFile();

	}


	//vector<u_int32_t> _unitigIndexes;
	struct UnitigSequence{
		DnaBitset* _seqBitset;
		u_int32_t _overlapSizePlus;
		u_int32_t _overlapSizeMinus;
	};
	vector<UnitigSequence> _unitigSequences;
	phmap::parallel_flat_hash_map<u_int32_t, u_int32_t> _unitigOrder;
	phmap::parallel_flat_hash_map<u_int32_t, u_int32_t> _unitigOrderRev;
	phmap::parallel_flat_hash_map<KmerVec, u_int32_t> _kmerVec_to_unitigIndex;

	void createUnitigSequences(){
		string readFilename = _tmpDir + "/input.txt";

		string toBasespaceType = "";
		if(_dataType == 0){ //Hifi
			toBasespaceType = "toBasespace_hifi";
		}
		else if(_dataType == 1){ //nanopore
			toBasespaceType = "toBasespace_ont";
		}
		string command = _filename_exe + " " + toBasespaceType + " " + " " + _tmpDir + " " + _passDir + "/assembly_graph.gfa.unitigs " + " " + _unitigFilename + " " + readFilename  + " --threads " + to_string(_nbCores);
		Utils::executeCommand(command, _tmpDir);
	}


	void loadUnitigs(){
		

		ReadParserParallel readParser(_unitigFilename, true, false, 1);
		readParser.parse(LoadUnitigsFunctor(*this));

	}

	class LoadUnitigsFunctor {

		public:

		GenerateGfa& _parent;
		MinimizerParser* _minimizerParser;
		EncoderRLE _encoderRLE;

		LoadUnitigsFunctor(GenerateGfa& parent) : _parent(parent){
			_minimizerParser = new MinimizerParser(_parent._minimizerSize, _parent._minimizerDensity_assembly);
			_minimizerParser->_trimBps = 0;
		}

		LoadUnitigsFunctor(const LoadUnitigsFunctor& copy) : _parent(copy._parent){
			_minimizerParser = new MinimizerParser(_parent._minimizerSize, _parent._minimizerDensity_assembly);
			_minimizerParser->_trimBps = 0;
		}

		~LoadUnitigsFunctor(){
			delete _minimizerParser;
		}


		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;

			string rleSequence;
			vector<u_int64_t> rlePositions;
			_encoderRLE.execute(read._seq.c_str(), read._seq.size(), rleSequence, rlePositions, _parent._useHomopolymerCompression);


			vector<MinimizerType> minimizers;
			vector<u_int32_t> minimizers_pos;
			vector<u_int8_t> minimizers_directions;
			_minimizerParser->parse(rleSequence, minimizers, minimizers_pos, minimizers_directions);


			u_int32_t overlapSizePlus = 0;
			u_int32_t overlapSizeMinus = 0;

			if(minimizers.size() < _parent._kminmerSize){
				//cout << read._header << endl;
				//cout << "lala " << minimizers.size() << " " << read._seq.size() << " " << rleSequence.size() << endl;

				
			}
			else{
				overlapSizePlus = read._seq.size() - rlePositions[minimizers_pos[minimizers.size()-_parent._kminmerSize+1]];
				overlapSizeMinus = rlePositions[minimizers_pos[_parent._kminmerSize-2]+_parent._minimizerSize];
			}
			//rlePositions[pos]; i<rlePositions[pos+_readSelection._minimizerSize]

			//cout << read._seq << " " << read._seq.size() << endl;
			
			//for(size_t i=0; i<minimizers.size(); i++){
			//	cout << i << ": " << rlePositions[minimizers_pos[i]] << endl;
			//}


			//cout << overlapSizeMinus << " " << overlapSizePlus << endl;
			//cout << readIndex << " " << minimizers.size() << endl;
			_parent._unitigSequences.push_back({new DnaBitset(read._seq), overlapSizePlus, overlapSizeMinus});

		}
		
	};



	void createAssemblyGraphFile(){

		string outputFilename = _passDir + "/assembly_graph.gfa.tmp";
		string outputFilenameNoSeq = _passDir + "/assembly_graph.noseq.gfa.tmp";
		ofstream outputFile(outputFilename);
		ofstream outputFileNoSeq(outputFilenameNoSeq);

		u_int64_t unitgIndex = 0;
        ifstream infile(_passDir + "/assembly_graph.gfa");

        std::string line;
        vector<string>* fields = new vector<string>();
        vector<string>* fields_optional = new vector<string>();


        while (std::getline(infile, line)){
            
            GfaParser::tokenize(line, fields, '\t');
            
            //cout << (*fields)[0] << endl;



			if((*fields)[0] == "S"){
				//cout << line << endl;
				//for(size_t i=0; i<(*fields).size(); i++){
				//	cout << i << ": " << (*fields)[i] << endl;
				//}
				//getchar();
				//cout << line << endl;
				//cout << _unitigSequences.size() << " " << unitgIndex << endl;
				DnaBitset* unitigBitset = _unitigSequences[unitgIndex]._seqBitset;
				char* unitigSequence = unitigBitset->to_string();
				string unitigSequenceStr = string(unitigSequence);


				string line = (*fields)[0] + "\t" + (*fields)[1] + "\t" + unitigSequenceStr + "\tLN:i:" + to_string(unitigSequenceStr.size()) + "\t" + (*fields)[4];
				string lineNoSeq = (*fields)[0] + "\t" + (*fields)[1] + "\t" + "*" + "\tLN:i:" + to_string(unitigSequenceStr.size()) + "\t" + (*fields)[4];
				//cout << line << endl;

				outputFile << line << endl;
				outputFileNoSeq << lineNoSeq << endl;

				free(unitigSequence);
				delete unitigBitset;

				string name = (*fields)[1];
				//size_t pos = name.find("utg");
				name.erase(0, 3);
				u_int32_t utg = stoull(name);

				_unitigOrder[utg] = unitgIndex;
				_unitigOrderRev[unitgIndex] = utg;

				unitgIndex += 1;
			}

            
        }

        infile.clear();
        infile.seekg(0, std::ios::beg);

        while (std::getline(infile, line)){
            
            GfaParser::tokenize(line, fields, '\t');
            
			if((*fields)[0] == "L"){

				//cout << line << endl;

				string nameFrom = (*fields)[1];
				nameFrom.erase(0, 3);
				u_int32_t from = stoull(nameFrom);

				bool fromOrient = (*fields)[2] == "+";

				string nameTo = (*fields)[3];
				nameTo.erase(0, 3);
				u_int32_t to = stoull(nameTo);

				bool toOrient = (*fields)[4] == "+";

				/*
				//cout << _unitigSequences[_unitigOrder[from]]._overlapSizePlus << endl;
				//cout << _unitigSequences[_unitigOrder[from]]._overlapSizeMinus << endl;
				
				//cout << _unitigSequences[_unitigOrder[to]]._overlapSizePlus << endl;
				//cout << _unitigSequences[_unitigOrder[to]]._overlapSizeMinus << endl;


				cout << _unitigSequences[_unitigOrder[from]]._seqBitset->to_string() << endl;
				cout << _unitigSequences[_unitigOrder[to]]._seqBitset->to_string() << endl;
				
				if((*fields)[2] == "+"){
					cout << _unitigSequences[_unitigOrder[from]]._overlapSizePlus << endl;
				}
				else{
					cout << _unitigSequences[_unitigOrder[from]]._overlapSizeMinus<< endl;
				}


				if((*fields)[4] == "+"){
					cout << _unitigSequences[_unitigOrder[to]]._overlapSizeMinus<< endl;
				}
				else{
					cout << _unitigSequences[_unitigOrder[to]]._overlapSizePlus << endl;
				}
				*/


				u_int32_t overlapSize = 0;
				
				if((*fields)[2] == "+"){
					overlapSize = _unitigSequences[_unitigOrder[from]]._overlapSizePlus;
				}
				else{
					overlapSize = _unitigSequences[_unitigOrder[from]]._overlapSizeMinus;
				}


				if((*fields)[4] == "+"){
					overlapSize = min(overlapSize, _unitigSequences[_unitigOrder[to]]._overlapSizeMinus);
				}
				else{
					overlapSize = min(overlapSize, _unitigSequences[_unitigOrder[to]]._overlapSizePlus);
				}

				//cout << overlapSize << endl;

				/*
				string& from = (*fields)[1];
				bool fromOrient = (*fields)[2] == "+";
				string& to = (*fields)[3];
				bool toOrient = (*fields)[4] == "+";
				u_int16_t overlap = std::stoull((*fields)[5]);

				u_int32_t from_id = std::stoull(from);
				u_int32_t to_id = std::stoull(to);
				*/

				string line = (*fields)[0] + "\t" + (*fields)[1] + "\t" + (*fields)[2] + "\t" +  (*fields)[3] + "\t" + (*fields)[4] + "\t" + to_string(overlapSize) + "M";
				//cout << line << endl;
				
				outputFile << line << endl;
				outputFileNoSeq << line << endl;

			}

            
        }

        delete fields;
        delete fields_optional;

		outputFile.close();
		outputFileNoSeq.close();


		
		fs::rename(outputFilename, _finalFilename);
		fs::rename(outputFilenameNoSeq, _finalFilenameNoSeq);

		_unitigOrder.clear();
		_unitigSequences.clear();

	}

	void indexAssemblyGraphUnitig(){

		KminmerParserParallel parser(_passDir + "/assembly_graph.gfa.unitigs", _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(IndexAssemblyGraphUnitigFunctor(*this));
	}

	class IndexAssemblyGraphUnitigFunctor {

		public:

		GenerateGfa& _parent;

		IndexAssemblyGraphUnitigFunctor(GenerateGfa& parent) : _parent(parent){
		}

		IndexAssemblyGraphUnitigFunctor(const IndexAssemblyGraphUnitigFunctor& copy) : _parent(copy._parent){
		}

		~IndexAssemblyGraphUnitigFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			
			#pragma omp critical
			{

				for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
					
					//_logFile << readIndex << " " << i << endl;
					const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

					KmerVec vec = kminmerInfo._vec;

					bool orientation = !kminmerInfo._isReversed;

					_parent._kmerVec_to_unitigIndex[vec] = kminmerList._readIndex;
				}
			}
		}
	};
	
	unordered_set<u_int32_t> _validContigIndex;
	ofstream _contigPathFile;
	phmap::parallel_flat_hash_map<u_int32_t, string> _contigIndex_to_headers;

	void generateContigPath(){
		Logger::get().info() << "Generating contig path";

		const string& contigFilename = _outputDir + "/contigs.fasta.gz";
		if(!fs::exists(contigFilename)){
			Logger::get().info() << "Can't find contig path at location: " + contigFilename;
			Logger::get().info() << "Skip contig path";
			return;
		}

		const string& contigDataFilename = _tmpDir + "/contig_data.txt";
		if(!fs::exists(contigDataFilename)){
			Logger::get().info() << "Can't find contig data at location: " + contigDataFilename;
			Logger::get().info() << "Skip contig path";
			return;
		}


		_contigPathFile = ofstream(_contigPathFilename);

		ReadParserParallel readParser(contigFilename, true, false, 1);
		readParser.parse(LoadContigIndexFunctor(*this));

		KminmerParserParallel parser(contigDataFilename, _minimizerSize, _kminmerSize, false, false, _nbCores);
		parser.parse(GenerateContigPathFunctor(*this));

		_validContigIndex.clear();
		_contigIndex_to_headers.clear();
		_contigPathFile.close();
	}

	class LoadContigIndexFunctor {

		public:

		GenerateGfa& _parent;

		LoadContigIndexFunctor(GenerateGfa& parent) : _parent(parent){
		}

		LoadContigIndexFunctor(const LoadContigIndexFunctor& copy) : _parent(copy._parent){
		}

		~LoadContigIndexFunctor(){
		}


		void operator () (const Read& read) {

			u_int64_t readIndex = read._index;
			
			//cout << read._header << endl;
			Utils::ContigHeader contigHeader = Utils::extractContigHeader(read._header);
			u_int32_t contigIndex = contigHeader._contigIndex;
			//cout << contigIndex << endl;

			_parent._validContigIndex.insert(contigIndex);
			_parent._contigIndex_to_headers[contigIndex] = read._header;
		}

	};

	class GenerateContigPathFunctor {

		public:

		GenerateGfa& _parent;

		GenerateContigPathFunctor(GenerateGfa& parent) : _parent(parent){
		}

		GenerateContigPathFunctor(const GenerateContigPathFunctor& copy) : _parent(copy._parent){
		}

		~GenerateContigPathFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			
			u_int32_t contigIndex = kminmerList._readIndex;
			if(_parent._validContigIndex.find(contigIndex) == _parent._validContigIndex.end()) return;

			u_int32_t _prevUnitigIndex = -1;
			vector<u_int32_t> path;

			for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
				
				//_logFile << readIndex << " " << i << endl;
				const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

				KmerVec vec = kminmerInfo._vec;

				bool orientation = !kminmerInfo._isReversed;

				if(_parent._kmerVec_to_unitigIndex.find(vec) == _parent._kmerVec_to_unitigIndex.end()){
					//cout << "can't find kmerVec ???" << endl;
					continue;
				}

				u_int32_t unitigIndex = _parent._kmerVec_to_unitigIndex[vec];

				if(unitigIndex != _prevUnitigIndex){
					_prevUnitigIndex = unitigIndex;
					//cout << unitigIndex << endl;
					path.push_back(unitigIndex);
				}
				//_toBasespace._kmerVecIndex[vec].push_back({(u_int32_t) kminmerList._readIndex, (u_int32_t) i});
			}

			if(path.size() == 0) return;

			#pragma omp critical
			{

				_parent._contigPathFile << _parent._contigIndex_to_headers[contigIndex];
				for(u_int32_t unitigIndex : path){
					_parent._contigPathFile << "\tutg" << _parent._unitigOrderRev[unitigIndex];
				}
				_parent._contigPathFile << endl;

			}
		}
	};


	ofstream _readPathFile;

	void generateReadPath(){
		Logger::get().info() << "Generating read path";

		const string& readDataFilename = _tmpDir + "/read_data_init.txt";
		if(!fs::exists(readDataFilename)){
			Logger::get().info() << "Can't find read data at location: " + readDataFilename;
			Logger::get().info() << "Skip read path";
			return;
		}

		_readPathFile = ofstream(_readPathFilename);

		bool useQuality = false;
		if(_dataType == 0){ //Hifi
			useQuality = false;
		}
		else if(_dataType == 1){ //nanopore
			useQuality = true;
		}

		KminmerParserParallel parser(readDataFilename, _minimizerSize, _kminmerSize, false, useQuality, _nbCores);
		parser._densityThreshold = _minimizerDensity_assembly;
		parser.parse(GenerateReadPathFunctor(*this));

		_readPathFile.close();
	}

	class GenerateReadPathFunctor {

		public:

		GenerateGfa& _parent;

		GenerateReadPathFunctor(GenerateGfa& parent) : _parent(parent){
		}

		GenerateReadPathFunctor(const GenerateReadPathFunctor& copy) : _parent(copy._parent){
		}

		~GenerateReadPathFunctor(){
		}

		void operator () (const KminmerList& kminmerList) {

			
			u_int32_t readIndex = kminmerList._readIndex;

			u_int32_t _prevUnitigIndex = -1;
			vector<u_int32_t> path;

			for(size_t i=0; i<kminmerList._kminmersInfo.size(); i++){
				
				//_logFile << readIndex << " " << i << endl;
				const ReadKminmerComplete& kminmerInfo = kminmerList._kminmersInfo[i];

				KmerVec vec = kminmerInfo._vec;

				bool orientation = !kminmerInfo._isReversed;

				if(_parent._kmerVec_to_unitigIndex.find(vec) == _parent._kmerVec_to_unitigIndex.end()){
					//cout << "can't find kmerVec ???" << endl;
					continue;
				}

				u_int32_t unitigIndex = _parent._kmerVec_to_unitigIndex[vec];

				if(unitigIndex != _prevUnitigIndex){
					_prevUnitigIndex = unitigIndex;
					//cout << unitigIndex << endl;
					path.push_back(unitigIndex);
				}
				//_toBasespace._kmerVecIndex[vec].push_back({(u_int32_t) kminmerList._readIndex, (u_int32_t) i});
			}

			if(path.size() == 0) return;


			#pragma omp critical
			{


				_parent._readPathFile << "r" << readIndex;
				for(u_int32_t unitigIndex : path){
					_parent._readPathFile << "\tutg" << _parent._unitigOrderRev[unitigIndex];
				}
				_parent._readPathFile << endl;

			}
		}
	};
};	

#endif 


