

	void solveBin_path(PathData& pathData, GraphSimplify* graph, bool forward){
		//if(_iter > 5000) return;

		bool orient_dummy = false;


		unordered_set<DbgEdge, hash_pair>& isEdgeVisited = pathData.isEdgeVisited;
		vector<u_int32_t>& prevNodes = pathData.prevNodes;
		u_int32_t utg_nodeIndex = pathData.source_nodeIndex_path;
		u_int32_t source_abundance = pathData.source_abundance;
		vector<u_int32_t> successors;
		//prevNodes.push_back(utg_nodeIndex);

		binNode(utg_nodeIndex, prevNodes, graph, pathData._index);



		//for(size_t lululu=0; lululu<500; lululu++){
		while(true){

			//if(_iter > 10000) return;

			cout << "----------- " << _iter << endl;
			//adjNode* node = graph->_nodes[utg_nodeIndex];
			vector<SuccessorData> data_successors;


			if(_iter >  1 && utg_nodeIndex == pathData.source_nodeIndex){
				cout << "Path complete! " << endl;
				//_pathDatas.push_back(pathData);
				return;
			}


			if(forward){
				graph->getSuccessors(utg_nodeIndex, pathData._abundanceCutoff_min, successors);
			}
			else{
				graph->getPredecessors(utg_nodeIndex, pathData._abundanceCutoff_min, successors);
			}
			/*
			///////////////////////////////////////////////////////////////
			bool isBranchingNode = false;
			int nbNeighbors = 0;
			while(node != nullptr){

				u_int64_t utg_n = node->val;
				u_int32_t unitigIndex = graph->nodeIndex_to_nodeName(utg_n, orient_dummy);
				//cout << unitigIndex << " " << _node_to_unitig[unitigIndex] << endl;
				if(_node_to_unitig[unitigIndex] == -1){ //Cleaned
					node = node->next;
					continue;
				}

				nbNeighbors += 1;
				node = node->next;
			}
			if(nbNeighbors > 1){
				isBranchingNode = true;
			}
			///////////////////////////////////////////////////////////////




			

			/////////////////////////////////////////////////////////////// Little hack because gfatools graph cleaning is not good, for bubble pop he kept path with very low abundance sometimes
			node = graph->_nodes[utg_nodeIndex];
			nbNeighbors=0;
			u_int32_t nnnn = -1;
			while(node != nullptr){

				u_int64_t utg_n = node->val;
				u_int32_t unitigIndex = graph->nodeIndex_to_nodeName(utg_n, orient_dummy);
				//cout << unitigIndex << " " << _node_to_unitig[unitigIndex] << endl;
				if(_node_to_unitig[unitigIndex] == -1){ //Cleaned
					node = node->next;
					continue;
				}

				nnnn = node->val;

				nbNeighbors += 1;
				node = node->next;
			}

			if(nbNeighbors == 1){ 

				if(isBranchingNode){
					DbgEdge edge = {utg_nodeIndex, nnnn};
					edge = edge.normalize();
					isEdgeVisited.insert(edge);
				}

				utg_nodeIndex = nnnn;
				binNode(utg_nodeIndex, prevNodes, graph, pathData._index);
				_iter += 1;
				continue;
			}
			///////////////////////////////////////////////////////////////
			*/
			
			//node = graph->_nodes[utg_nodeIndex];

			//while (node != nullptr) {

			/*
			if(successors.size() == 0){
				cout << "No successors" << endl;
				return;
			}
			else if(successors.size() == 1){
				utg_nodeIndex = successors[0];
				binNode(utg_nodeIndex, prevNodes, graph, pathData._index);
				_iter += 1;
				continue;
			}

			bool isBranchingNode = true;
			*/

			bool isBranchingNode = successors.size() > 1;
			
			for(u_int32_t utg_n : successors){

				//u_int64_t utg_n = node->val;


				u_int32_t current_unitigIndex = graph->_graphSuccessors->nodeIndex_to_nodeName(utg_nodeIndex, orient_dummy);
				u_int32_t unitigIndex = graph->_graphSuccessors->nodeIndex_to_nodeName(utg_n, orient_dummy);
				u_int32_t current_abundance = graph->_nodeAbundances[current_unitigIndex]; //_unitigDatas[current_unitigIndex]._meanAbundance;
				u_int32_t successor_abundance = graph->_nodeAbundances[unitigIndex]; //_unitigDatas[unitigIndex]._meanAbundance;

				//graph->_unitigs[graph->_nodeToUnitig[source_nodeIndex]]._abundance

				u_int32_t nbSharedReads = computeSharedReads(_unitigDatas[current_unitigIndex], _unitigDatas[unitigIndex]);

				//if(unitigIndex % 2 == 1){}
				cout << graph->_graphSuccessors->nodeToString(utg_nodeIndex) << " " << current_abundance << " " << " -> " <<  graph->_graphSuccessors->nodeToString(utg_n) << " " << successor_abundance << " " << nbSharedReads << endl;
				//cout << _node_to_unitig[unitigIndex] << endl;
				//cout << "Neigh: " << node_neighbor << endl;

				
				//if(nbSharedReads == 0) continue;
				
				//if(_node_to_unitig[unitigIndex] == -1){ //Cleaned
				//if(graph->_isNodeRemoved[utg_n]){ //Cleaned
				//	cout << "\t\tCleaned" << endl;
					//node = node->next;
				//	continue;
				//}

				//if(nbSharedReads <=  current_abundance / (nbNeighbors*4)){
				//	cout << "\t\tAbundance cutoff" << endl;
				//	node = node->next;
				//	continue;
				//}

				//if(nbSharedReads <=  current_abundance / (nbNeighbors*4)){
				//	cout << "\t\tAbundance cutoff" << endl;
				//	node = node->next;
				//	continue;
				//}

				if(_nbVisitedTimes[current_unitigIndex] > 100){
					cout << "\t\tExiting Infinite cycle" << endl;
					continue;
				}

				/*
				DbgEdge edge = {utg_nodeIndex, utg_n};
				edge = edge.normalize();
				//cout << (isEdgeVisited.find(edge) != isEdgeVisited.end()) << endl;
				if(isEdgeVisited.find(edge) != isEdgeVisited.end()){
					cout << "\t\tEdge visited" << endl;
					//node = node->next;
					continue;
				}
				*/


				SuccessorData successor = {utg_n, successor_abundance, 0, false};
				successor._sourceAbundance = abs((int)successor._abundance - (int)source_abundance);
				data_successors.push_back(successor);
				//successors.push_back(utg_n);
				//successors_abundance.push_back(successor_abundance);
				//predecessor_rank.push_back(0);
				//successor_finished.push_back(false);

				//node = node->next;
			}

			if(data_successors.size() == 0){
				cout << "No successors" << endl;
				return;
			}
			else if(data_successors.size() == 1){

				if(isBranchingNode){
					DbgEdge edge = {utg_nodeIndex, data_successors[0]._nodeIndex};
					edge = edge.normalize();
					isEdgeVisited.insert(edge);
				}

				utg_nodeIndex = data_successors[0]._nodeIndex;
				binNode(utg_nodeIndex, prevNodes, graph, pathData._index);
			}
			else{

				//u_int32_t currentUnitigIndex = _node_to_unitig[graph->_graphSuccessors->nodeIndex_to_nodeName(prevNodes[prevNodes.size()-1], orient_dummy)];
				u_int32_t currentUnitigIndex = graph->_nodeToUnitig[prevNodes[prevNodes.size()-1]];

				u_int32_t prevRank = 0;
				u_int32_t prevRank_unitig = 0;

				while(true){
					
					bool isFinished = true;
					for(size_t i=0; i<data_successors.size(); i++){
						if(!data_successors[i]._prevRankFinished){
							isFinished = false;
						}
					}
					//cout << "        " << isFinished << endl;
					if(isFinished) break;

					int prevIndex = prevNodes.size() - prevRank - 1;
					if(prevIndex < 0 ) break;

					u_int32_t current_nodeIndex = prevNodes[prevIndex];
					u_int32_t current_unitigIndex = graph->_graphSuccessors->nodeIndex_to_nodeName(current_nodeIndex, orient_dummy);
					if(currentUnitigIndex != graph->_nodeToUnitig[current_nodeIndex]){
						prevRank_unitig += 1;
						currentUnitigIndex = graph->_nodeToUnitig[current_nodeIndex];
					}

					//cout << current_unitigIndex << " " << _node_to_unitig[current_unitigIndex] << endl;
					string str_debug = "    " + to_string(prevRank_unitig) + ": " +  graph->_graphSuccessors->nodeToString(current_nodeIndex) + " utg" + to_string(graph->_nodeToUnitig[current_nodeIndex]);

					for(SuccessorData& successor : data_successors){
						if(successor._prevRankFinished){
							str_debug += "    " + graph->_graphSuccessors->nodeToString(successor._nodeIndex) + " " + "-";
							continue;
						}

						if(std::find(successor._processedNodeIndex.begin(), successor._processedNodeIndex.end(), current_unitigIndex) != successor._processedNodeIndex.end()){
							successor._prevRankFinished = true;
							str_debug += "    " + graph->_graphSuccessors->nodeToString(successor._nodeIndex) + " " + "-";
							continue;
						} 

						u_int32_t successor_unitigIndex = graph->_graphSuccessors->nodeIndex_to_nodeName(successor._nodeIndex, orient_dummy);
						
						u_int32_t nbSharedReads = computeSharedReads(_unitigDatas[current_unitigIndex], _unitigDatas[successor_unitigIndex]);
						if(nbSharedReads > pathData._abundanceCutoff_min/2){
						//if(nbSharedReads > successor._abundance/5){
						//if(nbSharedReads > 0){
						//if(nbSharedReads > 0){
							successor._prevRank = prevRank; //prevRank_unitig; //prevRank; //TODO better comparison in number of nucletoides
							successor._processedNodeIndex.push_back(current_unitigIndex);
						}
						else{
							successor._prevRankFinished = true;
						}

						//if(nbSharedReads == 0) continue;
						//if(nbSharedReads > 0 && nbSharedReads >=  data_successors[j]/5){
						//	successor_foundPath[j] = true;
						//	foundPath = true;
						//}

						str_debug += "    " + graph->_graphSuccessors->nodeToString(successor._nodeIndex) + " " + to_string(nbSharedReads);
						//cout << "    " << prevRank << ": " <<  graph->nodeToString(current_nodeIndex) << "     " << graph->nodeToString(successor._nodeIndex)  << ": " << nbSharedReads;
						
						//if(foundPath) break;
					}
					cout << str_debug << endl;


					prevRank += 1;

					//cout << currentUnitigIndex << "  " << _node_to_unitig[current_unitigIndex] << endl;


				}
				/*
				std::sort(data_successors.begin(), data_successors.end(), SuccessorComparator_byPrevRank);
				u_int32_t maxPrevRank = data_successors[0]._prevRank;
				vector<SuccessorData> successors_bestPrevRank;
				for(SuccessorData& successor : data_successors){
					if(successor._prevRank == maxPrevRank){
						successors_bestPrevRank.push_back(successor);
					}
				}
				*/

				std::sort(data_successors.begin(), data_successors.end(), SuccessorComparator_byPrevRank);
				u_int32_t maxPrevRank = data_successors[0]._prevRank;
				vector<SuccessorData> successors_bestPrevRank;
				for(SuccessorData& successor : data_successors){
					if(successor._prevRank > maxPrevRank-5){
						successors_bestPrevRank.push_back(successor);
					}
				}

				if(successors_bestPrevRank.size() == 1){


					DbgEdge edge = {utg_nodeIndex, successors_bestPrevRank[0]._nodeIndex};
					edge = edge.normalize();
					isEdgeVisited.insert(edge);


					utg_nodeIndex = successors_bestPrevRank[0]._nodeIndex;
					binNode(utg_nodeIndex, prevNodes, graph, pathData._index);
				}
				else{
					
					return;
					/*
					cout << "Starting branching path" << endl;
					
					int pathIndex = pathData._index + 1;
					for(SuccessorData& successor : successors_bestPrevRank){
							
						DbgEdge edge = {utg_nodeIndex, successor._nodeIndex};
						edge = edge.normalize();
						isEdgeVisited.insert(edge);

						PathData pData = {pathIndex, pathData.isEdgeVisited, pathData.prevNodes, pathData.source_abundance, pathData.source_nodeIndex, successor._nodeIndex, pathData._abundanceCutoff_min};
						solveBin_path(pData, graph);

						pathIndex += 1;
						
						//return; //TO REMOVE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						
					}
					
					return;
					*/
					/*
					std::sort(successors_bestPrevRank.begin(), successors_bestPrevRank.end(), SuccessorComparator_byAbundance);
					u_int32_t minSourceAbundance = successors_bestPrevRank[0]._sourceAbundance;
					vector<SuccessorData> successors_bestAbundance;
					for(SuccessorData& successor : successors_bestPrevRank){
						if(successor._sourceAbundance == minSourceAbundance){
							successors_bestAbundance.push_back(successor);
						}
					}

					if(successors_bestAbundance.size() == 1){

						DbgEdge edge = {utg_nodeIndex, successors_bestPrevRank[0]._nodeIndex};
						edge = edge.normalize();
						isEdgeVisited.insert(edge);

						utg_nodeIndex = successors_bestAbundance[0]._nodeIndex;
						binNode(utg_nodeIndex, prevNodes, graph);
					}
					else{
						cout << "todo" << endl;
						
						DbgEdge edge = {utg_nodeIndex, successors_bestPrevRank[0]._nodeIndex};
						edge = edge.normalize();
						isEdgeVisited.insert(edge);

						utg_nodeIndex = successors_bestAbundance[0]._nodeIndex;
						binNode(utg_nodeIndex, prevNodes, graph);
					}
					*/
				}

			}

			_iter += 1;

		}
	}
	


































































/*
	string kmer = seq.substr(0, k);
    uint64_t hVal, fhVal=0, rhVal=0; // canonical, forward, and reverse-strand hash values
    hVal = NTC64(kmer.c_str(), k, fhVal, rhVal); // initial hash value
    ...
    for (size_t i = 0; i < seq.length() - k; i++) 
    {
        hVal = NTC64(seq[i], seq[i+k], k, fhVal, rhVal); // consecutive hash values
        ...
    }
	*/

	/*
	IBank* inbank = Bank::open(_inputFilename);

	
	Iterator<Sequence>* itSeq = createIterator<Sequence> (
														inbank->iterator(),
														inbank->estimateNbItems(),
														"Parsing reads"
														);

	LOCAL (itSeq);
		
	std::vector<Iterator<Sequence>*> itBanks =  itSeq->getComposition();
	u_int32_t readIndex = 0;
	u_int32_t datasetID = 0;

	gzFile file_readData = gzopen(_filename_readMinimizers.c_str(),"wb");
	*/
	/*
	ModelCanonical model (_kmerSize);
	ModelCanonical::Iterator itKmer (model);

	//ModelMinimizer model (63, 14);
    //const ModelCanonical& modelMinimizer = model.getMmersModel();
	vector<u_int64_t> kmers;
	vector<u_int64_t> minimizers_0;
	vector<u_int64_t> minimizers_1;
	vector<u_int64_t> minimizers_2;

	//unordered_map<u_int64_t, u_int64_t> minimCount;
	for (size_t i=0; i<itBanks.size(); i++)
	{
		itSeq = createIterator<Sequence> (itBanks[i], inbank->estimateNbItemsBanki(i), "lala");

		for (itSeq->first(); !itSeq->isDone(); itSeq->next()){


			Sequence& sequence = itSeq->item();

			ReadData readData = {sequence.getDataSize(), {}, NULL, false};
			_compositionManager->readToComposition(sequence, readData._composition);
			_readData.push_back(readData);

			//set<u_int64_t> minimizers_0_set;
			kmers.clear();
			minimizers_0.clear();
			minimizers_1.clear();
			minimizers_2.clear();
			//cout << "------------" << endl;
			read_headers.push_back(sequence.getComment());

			char* readseq = sequence.getDataBuffer();
			string sequence_str;

			char lastChar = '0';
			for(size_t i=0; i<sequence.getDataSize(); i++){
				if(readseq[i] == lastChar) continue;
				sequence_str += readseq[i];
				lastChar = readseq[i];
			}



			//exit(1);
			size_t nbMinimizersPerRead = 0;

			//u_int64_t lastMinimizer = -1;
			Data buf((char*)sequence_str.c_str());
			

			itKmer.setData (buf);

			vector<MinimizerPair> minimizerPairs;

			//cout << "----------" << endl;
			u_int64_t pos = 0;
			for (itKmer.first(); !itKmer.isDone(); itKmer.next()){

				kmer_type kmerMin = itKmer->value();
				//if(!itKmer->value().isValid()) continue;
				//kmer_type kmerMin = min(itKmer->value(), revcomp(itKmer->value(), _kmerSize));
				//if(lala < 100 ) cout << model.toString(itKmer->value()) << endl;
				//lala += 1;
				u_int64_t kmerValue = kmerMin.getVal();
				u_int64_t kmerHashed;
				MurmurHash3_x64_128 ((const char*)&kmerValue, sizeof(kmerValue), _seed, &_hash_otpt);
				kmerHashed = _hash_otpt[0];

				//cout << kmerHashed << endl;
				kmers.push_back(kmerHashed);
				//minimizers_0_set.insert(kmerHashed);

				if(pos >= w){
					u_int64_t minimizer = -1; //(*minimizers_0_set.begin());
					for(u_int64_t kmer : kmers){
						if(kmer < minimizer){
							minimizer = kmer;
						}
					}
					//cout << kmers[0] << endl;
					//auto it = minimizers_0_set.find(kmers[0]);
					//minimizers_0_set.erase(it);

					kmers.erase(kmers.begin());

					if(minimizers_0.size() == 0 || minimizer != minimizers_0[minimizers_0.size()-1]){
						minimizers_0.push_back(minimizer);
					}
					//cout << "Min: " << (*minimizers_0_set.begin()) << endl;
				}

				pos += 1;
			}

			//cout << minimizers_0.size() << endl;
			for(size_t w=0; w<minimizers_0.size()-windowSize; w++){
				u_int64_t m = -1;
				for(size_t i=0; i<windowSize; i++){
					if(minimizers_0[w+i] < m){
						m = minimizers_0[w+i];
					}
				}
				if(std::find(minimizers_1.begin(), minimizers_1.end(), m) == minimizers_1.end()){
					minimizers_1.push_back(m);
				}
			}

			//cout << minimizers_1.size() << endl;

			for(size_t w=0; w<minimizers_1.size()-windowSize; w++){
				u_int64_t m = -1;
				for(size_t i=0; i<windowSize; i++){
					if(minimizers_1[w+i] < m){
						m = minimizers_1[w+i];
					}
				}
				if(std::find(minimizers_2.begin(), minimizers_2.end(), m) == minimizers_2.end()){
					minimizers_2.push_back(m);
				}
			}

			cout << minimizers_2.size() << endl;

			u_int64_t lastMinimizer = -1;
			for(u_int64_t minimizer : minimizers_2){



				if(lastMinimizer != -1){

					//nbMinizersRead += 1;

					MinimizerPair minimizerPair1 = {lastMinimizer, minimizer};
					MinimizerPair minimizerPair2 = {minimizer, lastMinimizer};

					bool pair1_exists = minimizerPairs_to_reads.find(minimizerPair1) != minimizerPairs_to_reads.end();
					bool pair2_exists = minimizerPairs_to_reads.find(minimizerPair2) != minimizerPairs_to_reads.end();
					if(pair1_exists){
						minimizerPairs.push_back(minimizerPair1);
						//minimizerPairs_to_reads[minimizerPair1].push_back(readIndex);
					}
					else if(pair2_exists){
						minimizerPairs.push_back(minimizerPair2);
						//minimizerPairs_to_reads[minimizerPair2].push_back(readIndex);
					}
					else{
						minimizerPairs.push_back(minimizerPair1);
						//minimizerPairs_to_reads[minimizerPair1] = vector<u_int32_t>();
						//minimizerPairs_to_reads[minimizerPair1].push_back(readIndex);
					}

					//if(minimCount.find(minimizer) == minimCount.end()){
					//	minimCount[minimizer] = 0;
					//}

					//minimCount[minimizer] += 1;

					//if(minimCount[minimizer] > 1000){
						//cout << model.toString(itKmer->value()) << endl;
					//}



				}
				
				lastMinimizer = minimizer;
			}






			//---------------------------------------------------------------------------------
			//cout << minimizerPairs.size() << endl;
			unordered_map<u_int64_t, u_int64_t> minimizerPairCount;
			for(MinimizerPair& minimizerPair : minimizerPairs){
				if(minimizerPairs_to_reads.find(minimizerPair) == minimizerPairs_to_reads.end()) continue;
				
				
				for(u_int64_t r : minimizerPairs_to_reads[minimizerPair]) {

					if(minimizerPairCount.find(r) == minimizerPairCount.end()){
						minimizerPairCount[r] = 0;
					}
					minimizerPairCount[r] += 1;
				}
			}

			//cout << minimizerPairCount.size() << endl;

			//cout << "----------------" << endl;
			//for (auto& it: minimizerPairCount) {
			//	cout << it.first << " " << it.second << endl;
			//}

			std::vector<std::pair<u_int64_t, u_int64_t>> elems(minimizerPairCount.begin(), minimizerPairCount.end());
			std::sort(elems.begin(), elems.end(), Ralalalala);
			
			//cout << "-" << endl;

			u_int64_t readIndex_merged = -1;
			for (size_t i=0; i<elems.size(); i++) {
				

				u_int64_t read = elems[i].first;
				float dist = computeDistanceTNF(_readData[readIndex], _readData[read]);

				
				//cout << elems[i].first << " " << elems[i].second << " " << dist << endl;

				if(dist < 0.002){ //0.05
					//readIndex_merged = read; //! disabled
					//break;
				}
			}

			if(readIndex_merged == -1){
				for(MinimizerPair& minimizerPair : minimizerPairs){
					minimizerPairs_to_reads[minimizerPair].push_back(readIndex);
				}
			}
			else{
				for(MinimizerPair& minimizerPair : minimizerPairs){

					if(minimizerPairs_to_reads.find(minimizerPair) == minimizerPairs_to_reads.end()){
						minimizerPairs_to_reads[minimizerPair].push_back(readIndex_merged);
					}
					else{
						vector<u_int32_t>& minimizerPairReads = minimizerPairs_to_reads[minimizerPair];
						if(std::find(minimizerPairReads.begin(), minimizerPairReads.end(), readIndex_merged) == minimizerPairReads.end()){
							minimizerPairReads.push_back(readIndex_merged);
						}
					}


				}
				_readData[readIndex]._composition.clear();
			}

			//cout << minimizerPairs.size() << endl;
			//if(read_headers[readIndex] == "G3_0 S1_1"){
				//cout << minimizerPairs.size() << " " << _readData[readIndex]._length << endl;
			//}



			//---------------------------------------------------------------------------------



			read_to_dataset.push_back(datasetID);
			readIndex += 1;
		}
		
		datasetID += 1;
	}
	*/


	MDBG* mdbg = new MDBG(_kminmerSize);

	_minimizerPairMap = new MinimizerPairMap();
	_overlapGraph = new AdjGraph();
	
	//unordered_map<u_int64_t, u_int64_t> minimCount;
	//set<MinimizerPair> _minimizerPairs;
	//vector<MinimizerPair_Edge> _minimizerPairs_edges;

	unordered_map<MinimizerPair, u_int16_t> minimizerCounts;



	ModelCanonical model (_minimizerSize);
	ModelCanonical::Iterator itKmer (model);
	vector<u_int32_t> neighbors;

	hash<KmerVec> h;
	//_node_id = 0;

	for (size_t i=0; i<itBanks.size(); i++)
	{
		itSeq = createIterator<Sequence> (itBanks[i], inbank->estimateNbItemsBanki(i), "lala");

		for (itSeq->first(); !itSeq->isDone(); itSeq->next()){

			
			//cout << "-" << endl;
			Sequence& sequence = itSeq->item();

			//ReadData readData = {sequence.getDataSize(), {}};

			//stringstream readData;

			//string readData;
			//_compositionManager->readToComposition(sequence, readData._composition);
			//_readData.push_back(readData);

			char* readseq = sequence.getDataBuffer();
			string sequence_str;

			char lastChar = '0';
			for(size_t i=0; i<sequence.getDataSize(); i++){
				if(readseq[i] == lastChar) continue;
				sequence_str += readseq[i];
				lastChar = readseq[i];
			}

			//sequence.setData();
        	//char* sequence_rle = (char*)  MALLOC (bs->read->max);
			//cout << sequence.toString() << endl;
			//cout << sequence_str << endl;
			//cout << readseq[0] << endl;
			//cout << readseq[1] << endl;
			//cout << readseq[2] << endl;
			//cout << ((readseq[0]>>1)&3) << endl;
			//cout << ((readseq[1]>>1)&3) << endl;
			//cout << ((readseq[2]>>1)&3) << endl;

			//exit(1);
			size_t nbMinimizersPerRead = 0;

			//u_int64_t lastMinimizer = -1;
			Data buf((char*)sequence_str.c_str());



			//read_headers.push_back(sequence.getComment()); //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! to add

			//cout << sequence.getComment() << endl;
			//cout << sequence.getDataSize() << endl;
			itKmer.setData (buf);

			u_int64_t lastMinimizer = -1;
			vector<u_int64_t> minimizers;
			vector<u_int64_t> minimizers_pos;
			u_int64_t nbMinizersRead = 0;

			vector<MinimizerPair> minimizerPairs;
			
			//cout << "---------------" << endl;

			//int lala = 0;
			u_int64_t pos = 0;
			for (itKmer.first(); !itKmer.isDone(); itKmer.next()){

				kmer_type kmerMin = itKmer->value();
				//if(!itKmer->value().isValid()) continue;
				//kmer_type kmerMin = min(itKmer->value(), revcomp(itKmer->value(), _kmerSize));
				//if(lala < 100 ) cout << model.toString(itKmer->value()) << endl;
				//lala += 1;
				u_int64_t kmerValue = kmerMin.getVal();
				u_int64_t minimizer;
				MurmurHash3_x64_128 ((const char*)&kmerValue, sizeof(kmerValue), _seed, &_hash_otpt);
				minimizer = _hash_otpt[0];



				//if(minimizerCounts[minimizer] > 1000) cout << minimizer << endl;
				double kmerHashed_norm = ((double) minimizer) / maxHashValue;
				if(kmerHashed_norm < _minimizerDensity){

					minimizers.push_back(minimizer);
					minimizers_pos.push_back(pos);
					//cout << pos << endl;
					//_readData[readIndex]._minimizers.push_back(minimizer);
					//readData << minimizer << endl;

					//if(readIndex == 0){
						//cout << minimizer << endl;
						//gzwrite(file_readData, (char*)&minimizer, 8);
						//cout << () << endl;
						//cout << readData.str().size() << endl;
					//}
					//nbMinimizers += 1;
					//minimizers.push_back(kmerHashed);
					/*
					if(lastMinimizer != -1){
						nbMinizersRead += 1;

						MinimizerPair minimizerPair1 = {lastMinimizer, minimizer};
						MinimizerPair minimizerPair2 = {minimizer, lastMinimizer};

						bool pair1_exists = minimizerPairs_to_reads.find(minimizerPair1) != minimizerPairs_to_reads.end();
						bool pair2_exists = minimizerPairs_to_reads.find(minimizerPair2) != minimizerPairs_to_reads.end();
						if(pair1_exists){

							//u_int16_t minimizerCount = minimizerCounts[minimizerPair1];
							//if(minimizerCount > 10000){
							//	continue;
							//}
							//else{
							//	minimizerCounts[minimizerPair1] += 1;
							//}

							minimizerPairs.push_back(minimizerPair1);
							//minimizerPairs_to_reads[minimizerPair1].push_back(readIndex);
						}
						else if(pair2_exists){

							//u_int16_t minimizerCount = minimizerCounts[minimizerPair2];
							//if(minimizerCount > 10000){
							//	continue;
							//}
							//else{
							//	minimizerCounts[minimizerPair2] += 1;
							//}

							minimizerPairs.push_back(minimizerPair2);
							//minimizerPairs_to_reads[minimizerPair2].push_back(readIndex);
						}
						else{

							//u_int16_t minimizerCount = minimizerCounts[minimizerPair1];
							//if(minimizerCount > 10000){
							//	continue;
							//}
							//else{
							//	minimizerCounts[minimizerPair2] += 1;
							//}

							minimizerPairs.push_back(minimizerPair1);
							//minimizerPairs_to_reads[minimizerPair1] = vector<u_int32_t>();
							//minimizerPairs_to_reads[minimizerPair1].push_back(readIndex);
						}

						//if(minimCount.find(minimizer) == minimCount.end()){
						//	minimCount[minimizer] = 0;
						//}

						//minimCount[minimizer] += 1;

						//if(minimCount[minimizer] > 1000){
							//cout << model.toString(itKmer->value()) << endl;
						//}
					}

					lastMinimizer = minimizer;
					*/
				}

				//cout << kmerHashed << endl;
				pos += 1;
			}

			
			u_int16_t size = minimizers.size();
			gzwrite(file_readData, (const char*)&size, sizeof(size));
			gzwrite(file_readData, (const char*)&minimizers[0], size * sizeof(u_int64_t));
			
			//cout << "-------------------------- " << size << endl;

			//gzwrite(file_readData, "\n", 1);
			//readData << endl;
			//string readData_str = readData.str();
			//gzwrite(file_readData, readData_str.c_str(), readData_str.size());

			//cout << minimizers.size() << endl;
			//if(minimizers.size() >= windowSize)
			int i_max = ((int)minimizers.size()) - (int)_kminmerSize + 1;
			//cout << minimizers.size() << " " << i_max << endl;
			for(int i=0; i<i_max; i++){

				//cout << i << " " << i_max << endl;
				KmerVec vec;

				for(int j=i; j<i+_kminmerSize; j++){
					//cout << minimizers.size() << " " << (j) << endl;
					vec._kmers.push_back(minimizers[j]);
				}
				
				//cout << vec._kmers.size() << endl;
				u_int32_t length = minimizers_pos[i+1] - minimizers_pos[i]; //minimizers_pos[i+windowSize-1] - minimizers_pos[i];
				//cout << "L: " << length << endl;
				mdbg->addNode(vec.normalize(), length);
				/*
				KmerVec vec_reverse = vec;
				std::reverse(vec_reverse._kmers.begin(), vec_reverse._kmers.end());

				//cout << h(vec) << " " <<  h(vec_reverse) << endl;
				if(h(vec) < h(vec_reverse)){
					addNode(vec);
				}
				else{
					addNode(vec_reverse);
				}*/


			}

			/*
			for(MinimizerPair& minimizerPair : minimizerPairs){
				
				minimizerPairs_to_reads[minimizerPair].push_back(readIndex);

				minimizerCounts[minimizerPair] += 1;

				_minimizerPairMap->addNode(minimizerPair);
				bool added = _overlapGraph->addNode(_minimizerPairMap->pair_to_id(minimizerPair));

				if(added){
					//output_file_gfa << "S" << "\t" << _minimizerPairMap->pair_to_id(minimizerPair) << "\t" << "*" << "\t" << "LN:i:" << 0 << endl;
				}
			}

			if(minimizerPairs.size() >= 2){
				
				MinimizerPair lastPair = minimizerPairs[0];
				for(size_t i=1; i<minimizerPairs.size(); i++){
					bool added = _overlapGraph->addEdge_checkDuplicate(_minimizerPairMap->pair_to_id(lastPair), _minimizerPairMap->pair_to_id(minimizerPairs[i]), 0);
					
					if(added){
						//output_file_gfa << "L" << "\t" << _minimizerPairMap->pair_to_id(lastPair) << "\t" << "+" << "\t" << _minimizerPairMap->pair_to_id(minimizerPairs[i]) << "\t" << "+" << "\t" << "0M" << endl;
					}
					
					//_overlapGraph->addEdge_checkDuplicate(_minimizerPairMap->pair_to_id(minimizerPairs[i]), _minimizerPairMap->pair_to_id(lastPair), 0);

					lastPair = minimizerPairs[i];
				}
				
			}
			*/

			/*
			//---------------------------------------------------------------------------------
			//cout << minimizerPairs.size() << endl;
			unordered_map<u_int64_t, u_int64_t> minimizerPairCount;
			for(MinimizerPair& minimizerPair : minimizerPairs){
				if(minimizerPairs_to_reads.find(minimizerPair) == minimizerPairs_to_reads.end()) continue;
				
				
				for(u_int64_t r : minimizerPairs_to_reads[minimizerPair]) {

					if(minimizerPairCount.find(r) == minimizerPairCount.end()){
						minimizerPairCount[r] = 0;
					}
					minimizerPairCount[r] += 1;
				}
			}

			//cout << minimizerPairCount.size() << endl;

			//cout << "----------------" << endl;
			//for (auto& it: minimizerPairCount) {
			//	cout << it.first << " " << it.second << endl;
			//}

			std::vector<std::pair<u_int64_t, u_int64_t>> elems(minimizerPairCount.begin(), minimizerPairCount.end());
			std::sort(elems.begin(), elems.end(), Ralalalala);
			
			//if(elems.size() > 1000){
				//cout << elems.size() << endl;
			//}
			//cout << "-" << endl;
			//cout << elems.size() << endl;
			u_int64_t readIndex_merged = -1;
			for (size_t i=0; i<elems.size(); i++) {
				

				u_int64_t read = elems[i].first;
				float dist = computeDistanceTNF(_readData[readIndex], _readData[read]);

				
				//cout << elems[i].first << " " << elems[i].second << " " << dist << endl;

				if(dist < 0.0005){ //0.05 0.002 0.0005
					readIndex_merged = read; //! disabled
					break;
				}
			}

			if(readIndex_merged == -1){
				for(MinimizerPair& minimizerPair : minimizerPairs){
					minimizerPairs_to_reads[minimizerPair].push_back(readIndex);
				}
			}
			else{
				for(MinimizerPair& minimizerPair : minimizerPairs){

					if(minimizerPairs_to_reads.find(minimizerPair) == minimizerPairs_to_reads.end()){
						minimizerPairs_to_reads[minimizerPair].push_back(readIndex_merged);
					}
					else{
						vector<u_int32_t>& minimizerPairReads = minimizerPairs_to_reads[minimizerPair];
						if(std::find(minimizerPairReads.begin(), minimizerPairReads.end(), readIndex_merged) == minimizerPairReads.end()){
							minimizerPairReads.push_back(readIndex_merged);
						}
					}


				}
				_readData[readIndex]._composition.clear();
			}
			*/
			//cout << minimizerPairs.size() << endl;
			//if(read_headers[readIndex] == "G3_0 S1_1"){
				//cout << minimizerPairs.size() << " " << _readData[readIndex]._length << endl;
			//}

			/*
			//S1_2132 S1_4386
			string str2 = sequence.getComment();
			//cout << str2 << endl;
			if (str2.find("S1_2132") != std::string::npos || str2.find("S1_4386") != std::string::npos) {
				cout << str2 << endl;
				cout << sequence.getDataSize() << endl;

				for(MinimizerPair& minimizerPair : minimizerPairs){
					cout << minimizerPair._first << " " << minimizerPair._second << endl;
				}
			}
			*/

			//---------------------------------------------------------------------------------


			//cout << "Nb minimizers: " << nbMinizersRead << endl;
			_evaluation_readToDataset.push_back(datasetID);
			readIndex += 1;
		}


		datasetID += 1;
	}




    	/*
	vector<u_int32_t> node_to_unitig(mdbg_errorFree->_dbg_nodes.size(), 0);
	GfaParser gfaParser;
	AdjGraph* graph = gfaParser.createGraph("/home/gats/workspace/data/overlap_test/read_overlaps_notips_nobubbles.gfa", node_to_unitig);
	
	vector<vector<u_int32_t>> components;
	graph->computeConnectedComponents(components);
	
	cout << "Nb connected components: " << components.size() << endl;
	for(size_t i=0; i<components.size(); i++){
		if(components[i].size() > 50){
			cout << i <<": " << components[i].size() << endl;
		}
		//if(components[i].size() == 1) cout << components[i][0] << endl;
	}
	*/


	/*
	cout << _overlapGraph->_nbNodes << endl;
	cout << _overlapGraph->_nbEdges << endl;


	
	AdjGraph* minimizerGraph_cleaned = new AdjGraph();
	MinimizerPairMap* _minimizerPairMap_cleaned = new MinimizerPairMap();

	//for (auto& it: minimizerCounts) {
	//	if(it.second <= 1) continue;
	//	if(it.second <= 10) continue;
	//	cout << it.second << endl;
	//}

	for(size_t n=0; n<_overlapGraph->_nbNodes; n++){

		MinimizerPair& pair = _minimizerPairMap->id_to_pair(n);



		if(!checkRemoveNode(n, _overlapGraph, _minimizerPairMap, minimizerCounts)){
			//_overlapGraph->collectNeighbors(n, 1, neighbors);
			//if(minimizerCounts[pair] > 1 && minimizerCounts[pair] < 35){
			_minimizerPairMap_cleaned->addNode(pair);
			bool added = minimizerGraph_cleaned->addNode(_minimizerPairMap_cleaned->pair_to_id(pair));
			if(added){
				//output_file_gfa << "S" << "\t" << _minimizerPairMap->pair_to_id(pair) << "\t" << "*" << "\t" << "LN:i:" << 0 << "\t" << "dp:i:" << minimizerCounts[pair] << endl;
			}
		}


		adjNode* node = _overlapGraph->_nodes[n];

        while (node != nullptr) {
			
			u_int32_t nn = node->val;
			MinimizerPair& pair_nn = _minimizerPairMap->id_to_pair(nn);

			if(!checkRemoveNode(nn, _overlapGraph, _minimizerPairMap, minimizerCounts)){
				//if(minimizerCounts[pair_nn] > 1 && minimizerCounts[pair_nn] < 35){
				_minimizerPairMap_cleaned->addNode(pair_nn);
				bool added = minimizerGraph_cleaned->addNode(_minimizerPairMap_cleaned->pair_to_id(pair_nn));
				if(added){
					//output_file_gfa << "S" << "\t" << _minimizerPairMap->pair_to_id(pair_nn) << "\t" << "*" << "\t" << "LN:i:" << 0 << "\t" << "dp:i:" << minimizerCounts[pair_nn] << endl;
				}

				added = minimizerGraph_cleaned->addEdge_checkDuplicate(_minimizerPairMap_cleaned->pair_to_id(pair), _minimizerPairMap_cleaned->pair_to_id(pair_nn), 0);
				if(added){
					//output_file_gfa << "L" << "\t" << _minimizerPairMap->pair_to_id(pair) << "\t" << "+" << "\t" << _minimizerPairMap->pair_to_id(pair_nn) << "\t" << "+" << "\t" << "0M" << endl;
				}

			}

			node = node->next;
        }

	}

	cout << minimizerGraph_cleaned->_nbNodes << endl;
	cout << minimizerGraph_cleaned->_nbEdges << endl;

	output_file_gfa.close();
	*/

	/*
	vector<float> dists;
	for(size_t n=0; n<_readData.size(); n++){
		

		for(size_t nn=n+1; nn<_readData.size(); nn++){
			float dist = computeDistanceTNF(_readData[n], _readData[nn]);

			//cout << dist << endl;
			
			dists.push_back(dist);

		}
	}

	print_stats(dists);
	*/
	
	//cout << nbMinimizers << endl;

	/*
	u_int64_t processed = 0;

	vector<vector<u_int16_t>> readCoverages(readIndex);
	unordered_map<MinimizerPair, u_int16_t> readPairCount;

	cout << minimizerPairs_to_reads.size() << endl;

	for (auto& it: minimizerPairs_to_reads) {

		processed += 1;
		if(processed % 100000 == 0){
			float progress = ((float) processed) / minimizerPairs_to_reads.size();
			//cout << progress << endl;
		} 


		MinimizerPair minimizerPair = it.first;
		vector<u_int32_t>& readIds = it.second;



		//u_int32_t m1 = (u_int32_t)((minimizerPair & 0xFFFFFFFF00000000LL) >> 32);
		//u_int32_t m2 = (u_int32_t)(minimizerPair & 0xFFFFFFFFLL);
		//cout << "Read pair: " << m1 << " " << m2 << " " << minimizerPair << endl;

		//cout << readIds.size() << endl;
		//cout << "------------" << endl;
		//for(size_t k=0; k<readIds.size(); k++) {
		//	cout << readIds[k] << endl;
		//}



		if(readIds.size() == 1) continue;

		//cout << readIds.size() << endl;
		if(readIds.size() > 10000) continue;

		//cout << readIds.size() << endl;
		for(size_t i=0; i<readIds.size(); i++) {
			
				//cout << i << " " << readIds.size() << endl;

			u_int32_t read1 = readIds[i];

			//if(read1 == 9363) cout << "Reads: " << readIds.size() << endl; 

			for(size_t j=i+1; j<readIds.size(); j++) {

				u_int32_t read2 = readIds[j];
				//if(read2 == 9363) cout << "Reads: " << readIds.size() << endl; 


				//if ((read1 == 7721 && read2 == 9442) || read2 == 7721 && read1 == 9442) {
					//cout << "lala" << endl;
				//}

				//cout << read1 << " " << read2 << endl;

				if(read1 == read2){
					//cout << "------------" << endl;
					//for(size_t k=0; k<readIds.size(); k++) {
						//cout << readIds[k] << endl;
					//}
					continue;
				}

				float dist = computeDistanceTNF(_readData[read1], _readData[read2]);
				//float t = 0.01f + 
				if(dist > 0.6f){
					//cout << read1 << " " << read2 << " " << dist << endl;
					continue;
				}

				

				


				//if(_evaluation_readToDataset[read1] != _evaluation_readToDataset[read2]){
				//	cout << "Diff dataset: " << computeDistanceTNF(_readData[read1], _readData[read2]) << endl;
				//}
				//else{
				//	cout << "Same dataset: " << computeDistanceTNF(_readData[read1], _readData[read2]) << endl;
				//}

				MinimizerPair readPair = {read1, read2};
				//u_int64_t readPair = (u_int64_t) read1 << 32 | read2;

				if(readPairCount.find(readPair) == readPairCount.end()){
					//cout << "Overlap: " << read1 << " " << read2 << endl;
					readPairCount[readPair] = 0;
					//cout << readPairCount.size() << endl;
				}

				readPairCount[readPair] += 1;


				//if ((readPair._first == 7721 && read2 == 9442) || read2 == 7721 && read1 == 9442) {
					//cout << readPairCount[readPair] << endl;
				//}

				//cout << j << endl;

			}
		}

		
		//cout << "Reads: " << readIds.size() << endl;


	}


	*/
	/*
	for(size_t i=0; i<readCoverages.size(); i++){
		if(read_headers[i] == "G3_0 S1_1"){

			for(size_t cov : readCoverages[i]){
				cout << cov << endl;
			}

			float mean = 0;
			
			for(size_t cov : readCoverages[i]){
				mean += cov;
			}
			mean /= readCoverages[i].size();

			float var = 0;
			for(size_t cov : readCoverages[i]){
				var += pow((cov - mean), 2);
			}
			var /= (readCoverages[i].size() - 1);
			float sd = SQRT(var);
			
			cout << "Mean: " << mean << endl;
			cout << "Sd: " << sd << endl;
			cout << "Var: " << var << endl;

		}
	}
	*/

	/*
	set<u_int32_t> nodes;


	//vector<u_int32_t> nodes;

	//ofstream output_file("/home/gats/workspace/data/overlap_test/read_overlaps.txt");
	ofstream output_file_gfa("/home/gats/workspace/data/overlap_test/read_overlaps.gfa");

	u_int64_t nbOverlaps = 0;

	u_int64_t nbOverlaps_interGenomes = 0;

	
	//u_int64_t nbNodes = 0;
	for (auto& it: readPairCount) {
		u_int16_t count = it.second;
		//if(count <= 1) continue;


		MinimizerPair readPair = it.first;
		u_int32_t read1 = readPair._first;//(u_int32_t)((readPair & 0xFFFFFFFF00000000LL) >> 32);
		u_int32_t read2 = readPair._second;//(u_int32_t)(readPair & 0xFFFFFFFFLL);

		nodes.insert(read1);
		nodes.insert(read2);
		//nbNodes += 1;
	}
	
	GraphInfo* graphInfo = new GraphInfo();

	cout << "Nb nodes: " << nodes.size() << endl;
	//cout << readIndex << " " << nbNodes << endl;
	//u_int64_t nbNodes = readIndex;
	_overlapGraph = new AdjGraph(nodes.size());

	vector<Overlap> overlaps;

	int nbOverlapsLala = 0;
	for (auto& it: readPairCount) {
		
		u_int16_t count = it.second;
		if(count <= 1) continue;


		MinimizerPair readPair = it.first;

		u_int32_t read1 = readPair._first;//(u_int32_t)((readPair & 0xFFFFFFFF00000000LL) >> 32);
		u_int32_t read2 = readPair._second;//(u_int32_t)(readPair & 0xFFFFFFFFLL);

		overlaps.push_back({read1, read2, count});


		//if(read1 == read2) cout << "rofl " << read1 << endl;


		if(read1 == 9363 || read2 == 9363){
			nbOverlapsLala += 1;
			//cout << "ReadPairCount: " << nbOverlapsLala << " " << count << endl; 
		}


		//float dist = computeDistanceTNF(_readData[read1], _readData[read2]);
		//float t = 0.01f + count * 0.005f;
		//if(dist > t) continue; //To remove I think

		if(_evaluation_readToDataset[read1] != _evaluation_readToDataset[read2]){
			nbOverlaps_interGenomes += 1;
			//float dist = computeDistanceTNF(_readData[read1], _readData[read2]);
			//cout << "Bad overlaps: " <<  read1 << " " << read2 << " " << count << " " << dist << endl;
		}

		//if ((read1 == 7721 && read2 == 9442) || read2 == 7721 && read1 == 9442) {
			//cout << read_headers[read1] << " " << read_headers[read2] << endl;
		//}


		//if(read1 == 101) cout << _readData[read1]._graphVertex << endl;
		//if(read2 == 101) cout << _readData[read2]._graphVertex << endl;


		//output_file << read_headers[read1] << ";" << read_headers[read2] << ";" << count << endl; //!

		//cout << read1 << " " << read2 << " " << count << " " << (_evaluation_readToDataset[read1] == _evaluation_readToDataset[read2]) << endl;
		//if(!_readData[read1]._vertexCreated){
		//	_readData[read1]._vertexCreated = true;
			//nodes.push_back(read1);
			//boost::adjacency_list<>::vertex_descriptor v1 = boost::add_vertex(_overlapGraph);
			//_readData[read1]._graphVertex = v1;
			//_overlapGraph[v1]._readIndex = read1;

			//cout << "Create node: " << v1 << " " << read1 << endl;
			//if(read1 == 101) cout << "Added " << v1 << endl;

		//}
		//if(!_readData[read2]._vertexCreated){
		//	_readData[read2]._vertexCreated = true;
			//nodes.push_back(read2);
			//boost::adjacency_list<>::vertex_descriptor v1 = boost::add_vertex(_overlapGraph);
			//_readData[read2]._graphVertex = v1;
			//_overlapGraph[v1]._readIndex = read2;
			
			//cout << "Create node: " << v1 << " " << read2 << endl;
			//if(read2 == 101) cout << "Added " << v1 << endl;
		//}

		//if(read1 > nbNodes || read2 > nbNodes) cout << "allo" << endl;

		graphInfo->addNode(read1);
		graphInfo->addNode(read2);

		_overlapGraph->addEdge(graphInfo->readIndex_to_id(read1), graphInfo->readIndex_to_id(read2), 0);
		//cout << read1 << " " << read2 << " " << nbNodes << endl;

		//boost::add_edge(_readData[read1]._graphVertex, _readData[read2]._graphVertex, _overlapGraph);

		//output_file_gfa << "L" << "\t" << read1 << "\t" << "+" << "\t" << read2 << "\t" << "+" << "\t" << "0M" << endl;

		nbOverlaps += 1;

	}

	//vector<bool> hasMatch(readIndex, false);
	unordered_map<ReadIndexType, vector<ReadIndexType>> bestOverlaps;
	unordered_map<ReadIndexType, vector<ReadIndexType>> bestOverlaps_reverse;
	//cout << "----" << endl;
	std::sort(overlaps.begin(), overlaps.end(), OverlapComparator);
	for(Overlap& overlap : overlaps){

		ReadIndexType read1 = overlap._r1;
		ReadIndexType read2 = overlap._r2;


		if(bestOverlaps.find(read1) == bestOverlaps.end() && bestOverlaps_reverse.find(read2) == bestOverlaps_reverse.end()){

			bool isCycle = false;
			ReadIndexType currentRead = read1;
			while(true){

				if(bestOverlaps_reverse.find(currentRead) == bestOverlaps_reverse.end()) break;

				currentRead = bestOverlaps_reverse[currentRead];
				if(currentRead == read2){
					isCycle = true;
					break;
				}
			}

			if(!isCycle){
				bestOverlaps[read1] = read2;
				bestOverlaps_reverse[read2] = read1;
				continue;
			}
			
		}
		
		if(bestOverlaps.find(read2) == bestOverlaps.end() && bestOverlaps_reverse.find(read1) == bestOverlaps_reverse.end()){

			bool isCycle = false;
			ReadIndexType currentRead = read2;
			while(true){

				if(bestOverlaps_reverse.find(currentRead) == bestOverlaps_reverse.end()) break;
				currentRead = bestOverlaps_reverse[currentRead];
				if(currentRead == read1){
					isCycle = true;
					break;
				}
			}

			if(!isCycle){
				bestOverlaps[read2] = read1;
				bestOverlaps_reverse[read1] = read2;
			}
			
		}
		
		



		//else if(bestOverlaps.find(read2) == bestOverlaps.end()){
		//	bestOverlaps[read2] = read1;
		//	hasMatch[read1] = true;
		//}


		//cout << "Overlap: " << overlap._nbMinimizers << endl;
	}

	for (auto& it: bestOverlaps) {
		
		u_int32_t read1 = it.first;//(u_int32_t)((readPair & 0xFFFFFFFF00000000LL) >> 32);
		u_int32_t read2 = it.second;//(u_int32_t)(readPair & 0xFFFFFFFFLL);
		output_file_gfa << "L" << "\t" << read1 << "\t" << "+" << "\t" << read2 << "\t" << "+" << "\t" << "0M" << endl;
	}
	//for(size_t i=0; i<_readData.size(); i++){
	//	if(_readData[i]._composition.size() == 0) continue;
	//	output_file_gfa << "L" << "\t" << i << "\t" << "+" << "\t" << _readData[i]._readBestMatch << "\t" << "+" << "\t" << "0M" << endl;
	//}
	
	for(u_int32_t node : nodes){
		output_file_gfa << "S" << "\t" << node << "\t" << "*" << "\t" << "LN:i:" << _readData[node]._length << endl;
	}

	output_file_gfa.close();
	nodes.clear();

	cout << "Nb overlaps: " <<  nbOverlaps << endl;
	cout << "Nb overlaps inter genomes: " <<  nbOverlaps_interGenomes << endl;

	*/
	/*
	//_overlapGraph->display_AdjList(0, graphInfo);
	cout << "--------" << endl;
	vector<u_int32_t> neighbors;
	_overlapGraph->collectNeighbors(0, 2, neighbors);
	for(u_int32_t n : neighbors){
		cout << n << endl;
	}

	set<u_int32_t> lala;
	cout << "--------" << endl;
	_overlapGraph->collectNeighbors(0, 1, neighbors);
	for(u_int32_t n : neighbors){
		lala.insert(n);
		vector<u_int32_t> neighbors2;
		_overlapGraph->collectNeighbors(n, 1, neighbors2);
		for(u_int32_t nn : neighbors2){
			lala.insert(nn);
		}
	}

	for(auto lalala : lala){
		cout << lalala << endl;
	}

	//output_file.close();

	//_overlapGraph->display_AdjList(0);
	*/
	/*
	cout << "Nb nodes: " << boost::num_vertices(_overlapGraph) << endl;

	std::vector<int> component (boost::num_vertices (_overlapGraph));
	size_t num_components = boost::connected_components (_overlapGraph, &component[0]);
	cout << "Nb components: " << num_components << endl;

	vector<vector<ReadIndexType>> readPerCompoenents(num_components);
	vector<u_int64_t> nbNodePerComponents(num_components, 0);

	for (size_t i = 0; i < boost::num_vertices (_overlapGraph); i++){
		nbNodePerComponents[component[i]] += 1;

		readPerCompoenents[component[i]].push_back(_overlapGraph[i]._readIndex);
		//cout <<  "Node: " << i << " Read: " << graph[i]._readIndex << endl;
	}
	
	for(size_t i=0; i<num_components; i++){
		if(nbNodePerComponents[i] < 100) continue;
		cout << "Compoenents " << i << ": " << nbNodePerComponents[i] << endl;
	}

	cout << "Nb components: " << num_components << endl;
	*/
	/*
	for(size_t i=0; i<readPerCompoenents.size(); i++){
		cout << "---------------- " << i << endl;
		for(ReadIndexType ri : readPerCompoenents[i]){
			cout << _evaluation_readToDataset[ri] << endl;
		}
	}
	*/

	//createSimilarityGraph(graphInfo);


/*
static void writeGfa(AdjGraph* graph, const string& outputFilename){

        cout << "Dumping graph: " << outputFilename << endl;

        //cout << graph->_nbNodes << endl;
	    vector<u_int64_t> neighbors;

	    ofstream outputFile(outputFilename);

        for(size_t n=0; n<graph->_nbNodes; n++){
            //if(graph->_nodes[n]->isBidirection) continue;

            //cout << n << " " << graph->_graphInfo->_unitigs_length.size() << endl;
            outputFile << "S" << "\t" << n << "\t" << "*" << "\t" << "LN:i:" << graph->_graphInfo->_unitigs_length[n] << endl;


            adjNode* node = graph->_nodes[n];
            while (node != nullptr) {

                if(node->isBidirection){
                    node = node->next;
                    continue;
                }

                string from = "";
                if(node->directionFrom) from = "+"; else from = "-";

                string to = "";
                if(node->directionTo) to = "+"; else to = "-";

                outputFile << "L" << "\t" << n << "\t" << from << "\t" << node->val << "\t" << to << "\t" << "0M" << endl;

                node = node->next;

            }


        }

        outputFile.close();
    }

*/



/*
void Bloocoo::createSimilarityGraph(GraphInfo* graphInfo){


	
	ofstream stats_file("/home/gats/workspace/run/histos/binner_stats.csv");
	ofstream graph_output_file("/home/gats/workspace/run/histos/similarityGraph.txt");


	u_int64_t nbEdgeIntra = 0;
	u_int64_t nbEdgeInter = 0;

	vector<float> distTNF_intra;
	vector<float> distTNF_inter;
	vector<u_int32_t> neighbors;

	u_int64_t nbEdges = 0;

	for(size_t n=0; n<_overlapGraph->_nbNodes; n++){

		ReadIndexType read = graphInfo->id_to_readIndex(n);
		//ReadIndexType read = _overlapGraph[n]._readIndex;
		u_int32_t read_datasetId = _evaluation_readToDataset[read];

		//cout << n << " " << read << endl;
		_overlapGraph->collectNeighbors(n, 10, neighbors);

		//cout << "------" << endl;
		//auto neighbours = boost::adjacent_vertices(n, _overlapGraph);
		//for (auto nn : make_iterator_range(neighbours)){

		for (u_int64_t nn : neighbors){

			//cout << nn << endl;
			//ReadIndexType read_neighbor = _overlapGraph[nn]._readIndex;
			ReadIndexType read_neighbor = graphInfo->id_to_readIndex(nn);
			u_int32_t read_neighbor_datasetId = _evaluation_readToDataset[read_neighbor];

			

			float dist = computeDistanceTNF(_readData[read], _readData[read_neighbor]);

			//if(n == 0){
				//cout << dist << endl;
			//}
			if(read_datasetId == read_neighbor_datasetId){
				nbEdgeIntra += 1;
				distTNF_intra.push_back(dist);
				//cout << dist << endl;
			}
			else{
				nbEdgeInter += 1;
				distTNF_inter.push_back(dist);
				//cout << dist << endl;
			}
			
			if(dist > 0.05) continue;
			

			float weight = 1.0 - dist;
			graph_output_file << read << " " << read_neighbor << " " << weight << endl;
			nbEdges += 1;

		}
		
	}
	
	cout << "Nb edges total: " << nbEdges << endl;
	cout << "Nb edges intra: " << nbEdgeIntra << endl;
	cout << "Nb edges inter: " << nbEdgeInter << endl;
	cout << "Intra dists:" << endl;
	print_stats(distTNF_intra);
	cout << "Inter dists:" << endl;
	print_stats(distTNF_inter);

	graph_output_file.close();


	stats_file.close();
}
*/
































#include <Bloocoo.hpp>


Bloocoo::Bloocoo () : Tool("bloocoo")
{

	getParser()->push_back (new OptionOneParam (STR_INPUT, "input file", true));
	getParser()->push_back (new OptionOneParam (STR_OUTPUT, "output dir", true));
	getParser()->push_back (new OptionOneParam (STR_MINIM_SIZE, "minimizer length", false, "16"));
	getParser()->push_back (new OptionOneParam (STR_KMINMER_SIZE, "k-min-mer length", false, "3"));
	getParser()->push_back (new OptionOneParam (STR_DENSITY, "density of minimizers", false, "0.005"));
	getParser()->push_back (new OptionOneParam (STR_INPUT_DIR, "input dir", false, ""));

}





void Bloocoo::execute ()
{

	_compositionManager = new CompositionManager(4);

	//int w = 80;
	_kminmerSize = getInput()->getInt(STR_KMINMER_SIZE);
	_inputFilename = getInput()->getStr(STR_INPUT);
	_minimizerSize = getInput()->getInt(STR_MINIM_SIZE);
	_outputDir = getInput()->getStr(STR_OUTPUT);
	_minimizerDensity = getInput()->getDouble(STR_DENSITY);

	if(!System::file().doesExist (_outputDir)) System::file().mkdir(_outputDir, -1);

	cout << endl;
	cout << "Input: " << _inputFilename << endl;
	cout << "Output dir: " << _outputDir << endl;
	cout << "Kminmer length: " << _kminmerSize << endl;
	cout << "Minimizer length: " << _minimizerSize << endl;
	cout << "Density: " << _minimizerDensity << endl;
	cout << endl;

	_inputDir = getInput()->get(STR_INPUT_DIR) ? getInput()->getStr(STR_INPUT_DIR) : "";

	_filename_readMinimizers = _outputDir + "/read_data.gz";


	if(_inputDir != ""){
		execute_binning();
		return;
	}

	unordered_map<MinimizerPair, vector<u_int32_t>> minimizerPairs_to_reads;

	vector<string> read_headers;

	//float minimizerDensity = 0.005; // 0.004; 0.0008
	u_int64_t maxHashValue = -1;
	//cout << maxHashValue << endl;
	//u_int64_t nbMinimizers = 0;

	u_int64_t _hash_otpt[2];
	int _seed = 42;
	setDispatcher (new SerialDispatcher());



	//std::vector<Iterator<Sequence>*> itBanks =  itSeq->getComposition();
	u_int32_t readIndex = 0;
	u_int32_t datasetID = 0;

	gzFile file_readData = gzopen(_filename_readMinimizers.c_str(),"wb");


	MDBG* mdbg = new MDBG(_kminmerSize);
	hash<KmerVec> h;

	std::ifstream infile(_inputFilename.c_str());
	std::string line;
	int total_kminmers = 0;
	while (std::getline(infile, line))
	{
		//cout << line << endl;

		gzFile fp;
		kseq_t *seq;
		int slen = 0, qlen = 0;
		fp = gzopen(line.c_str(), "r");
		seq = kseq_init(fp);
		while (kseq_read(seq) >= 0){
			//cout << readIndex << " " << strlen(seq->seq.s) << endl;

			//cout << "--------------" << endl;
			string sequence_str = "";
			char lastChar = '0';

			for(size_t i=0; i<strlen(seq->seq.s); i++){
				if(seq->seq.s[i] == lastChar) continue;
				sequence_str += seq->seq.s[i];
				lastChar = seq->seq.s[i];
			}


			vector<u_int64_t> minimizers;
			vector<u_int64_t> minimizers_pos;

			//string kmer = sequence_str.substr(0, _minimizerSize);
			//cout << kmer << endl;
			//u_int64_t minimizer, fhVal=0, rhVal=0; // canonical, forward, and reverse-strand hash values
			//minimizer = NTC64(kmer.c_str(), _minimizerSize, fhVal, rhVal); // initial hash value

			string kmer = sequence_str.substr(0, _minimizerSize);

			int nbKmers = 0;
			for (size_t i = 0; i < sequence_str.size() - _minimizerSize; i++) { //MISSING LAST KMER A CHECK ?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


				kmer_type kmerMin = itKmer->value();
				u_int64_t kmerValue = kmerMin.getVal();
				u_int64_t minimizer;
				MurmurHash3_x64_128 ((const char*)&kmerValue, sizeof(kmerValue), _seed, &_hash_otpt);
				minimizer = _hash_otpt[0];

				//cout << i << " " << kmer << endl;

				//u_int64_t minimizer = NTC64(kmer.c_str(), _minimizerSize);; //NTC64(sequence_str[i], sequence_str[i+_minimizerSize], _minimizerSize, fhVal, rhVal); // consecutive hash values
				
				//cout << hVal << endl;

				double kmerHashed_norm = ((double) minimizer) / maxHashValue;
				//cout << minimizer << " " << kmerHashed_norm << endl;
				if(kmerHashed_norm < _minimizerDensity){
					//cout << minimizer << endl;
					minimizers.push_back(minimizer);
					minimizers_pos.push_back(i);
					
				}

				kmer.erase(kmer.begin());
				kmer += sequence_str[i+_minimizerSize+1];

				nbKmers += 1;
				//cout << kmerHashed << endl;
				//pos += 1;
			}

			//cout << nbKmers << " " << minimizers.size() << endl;
			//cout << minimizers.size() << endl;

			u_int16_t size = minimizers.size();
			gzwrite(file_readData, (const char*)&size, sizeof(size));
			gzwrite(file_readData, (const char*)&minimizers[0], size * sizeof(u_int64_t));
			
			int lala =0;
			int i_max = ((int)minimizers.size()) - (int)_kminmerSize + 1;
			for(int i=0; i<i_max; i++){

				KmerVec vec;

				for(int j=i; j<i+_kminmerSize; j++){
					vec._kmers.push_back(minimizers[j]);
				}
				
				u_int32_t length = minimizers_pos[i+_kminmerSize-1] - minimizers_pos[i]; //minimizers_pos[i+windowSize-1] - minimizers_pos[i];
				
				
				mdbg->addNode(vec.normalize(), length);
				lala += 1;
				total_kminmers += 1;
			}

			//cout << lala << endl;




			_evaluation_readToDataset.push_back(datasetID);
			readIndex += 1;
			//COUNT PREFIXES
			//std::copy(seq->seq.s, seq->seq.s + 2, begin(prefix));
			//if (prefix_counter.count(prefix) == 0){
			//	prefix_counter[prefix] = 1;
			//	} else prefix_counter[prefix]++;
		}
		std::cout << "Nb reads: " << readIndex << '\n';
		kseq_destroy(seq);
		gzclose(fp);

		datasetID += 1;
		//std::istringstream iss(line);
		//int a, b;
		//if (!(iss >> a >> b)) { break; } // error

		// process pair (a,b)
	}

	
	cout << total_kminmers << endl;
	gzclose(file_readData);


	file_readData = gzopen(_filename_readMinimizers.c_str(),"rb");








	cout << "Nb nodes: " << mdbg->_dbg_nodes.size() << endl;
	cout << "Cleaning errors..." << endl;

	MDBG* mdbg_errorFree = new MDBG(_kminmerSize);

	//for(size_t readIndex=0; readIndex<_readData.size(); readIndex++) {
	//	ReadData& readData = _readData[readIndex];
	//	vector<u_int64_t>& minimizers = readData._minimizers;


	while(true){
		
		u_int16_t size;
		vector<u_int64_t> minimizers;
		gzread(file_readData, (char*)&size, sizeof(size));

		if(gzeof(file_readData)) break;
		
		minimizers.resize(size);
		gzread(file_readData, (char*)&minimizers[0], size * sizeof(u_int64_t));

		//cout << "haaa " << minimizers.size() << endl;
		//for(size_t i=0; i<minimizers.size(); i++){
		//	cout << minimizers[i] << endl;
		//}


		vector<KmerVec> kminmers;

		int i_max = ((int)minimizers.size()) - (int)_kminmerSize;
		for(int i=0; i<i_max; i++){

			KmerVec vec;

			for(int j=i; j<i+_kminmerSize; j++){
				vec._kmers.push_back(minimizers[j]);
			}
			kminmers.push_back(vec.normalize());
		}

		vector<u_int16_t> abundances;

		//double abundance_mean = 0;
		for(KmerVec& kminmer : kminmers){
			//abundance_mean += mdbg->_dbg_nodes[kminmer]._abundance;
			abundances.push_back(mdbg->_dbg_nodes[kminmer]._abundance);
		}
		//abundance_mean /= kminmers.size();

		float cutoff = median(abundances) / 2;

		//if(abundance_mean < 10){ 
		//cout << "----------------" << endl;
		//cout << "Mean: " << abundance_mean << endl;
		//cout << "Median: " << median(abundances) << endl;
		//for(KmerVec& kminmer : kminmers){
		//	cout << mdbg->_dbg_nodes[kminmer]._abundance << endl;
		//}

		//}
		//cout << "----------------" << endl;
		//cout << "Mean: " << abundance_mean << endl;
		for(KmerVec& kminmer : kminmers){
			if(mdbg->_dbg_nodes[kminmer]._abundance <= 2){
				if(mdbg->_dbg_nodes[kminmer]._abundance <= cutoff) continue;
			}


			mdbg_errorFree->addNode(kminmer, mdbg->_dbg_nodes[kminmer]._length);
			mdbg_errorFree->_dbg_nodes[kminmer]._abundance = mdbg->_dbg_nodes[kminmer]._abundance;

		}


	}

	//cout << "Nb edges: " << nbEdges << endl;

	delete mdbg;
	
	//cout << _dbg_edges.size() << endl;

	u_int64_t nbEdges = 0;

	string gfa_filename = _outputDir + "/minimizer_graph.gfa";
	ofstream output_file_gfa(gfa_filename);

	for(auto vec_id : mdbg_errorFree->_dbg_nodes){

		KmerVec vec = vec_id.first;
		KmerVec vec_rev = vec_id.first.reverse();
		u_int32_t id = vec_id.second._index;

		output_file_gfa << "S" << "\t" << id << "\t" << "*" << "\t" << "LN:i:" << vec_id.second._length << "\t" << "dp:i:" << vec_id.second._abundance << endl;

		for(KmerVec& v : mdbg_errorFree->_dbg_edges[vec.prefix().normalize()]){
			if(v==vec) continue;
			KmerVec v_rev = v.reverse();

			if (vec.suffix() == v.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "+" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "+" << "\t" << "0M" << endl;
				//vec_add_edge("+", "+");
			}
			if (vec.suffix() == v_rev.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "+" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "-" << "\t" << "0M" << endl;
				//vec_add_edge("+", "-");
			}
			if (vec_rev.suffix() == v.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "-" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "+" << "\t" << "0M" << endl;
				//vec_add_edge("-", "+");
			}
			if (vec_rev.suffix() == v_rev.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "-" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "-" << "\t" << "0M" << endl;
				//vec_add_edge("-", "-");
			}

		}
		for(KmerVec& v : mdbg_errorFree->_dbg_edges[vec.suffix().normalize()]){
			if(v==vec) continue;
			KmerVec v_rev = v.reverse();

			if (vec.suffix() == v.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "+" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "+" << "\t" << "0M" << endl;
				//vec_add_edge("+", "+");
			}
			if (vec.suffix() == v_rev.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "+" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "-" << "\t" << "0M" << endl;
				//vec_add_edge("+", "-");
			}
			if (vec_rev.suffix() == v.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "-" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "+" << "\t" << "0M" << endl;
				//vec_add_edge("-", "+");
			}
			if (vec_rev.suffix() == v_rev.prefix()) {
				nbEdges += 1;
				output_file_gfa << "L" << "\t" << id << "\t" << "-" << "\t" << mdbg_errorFree->_dbg_nodes[v]._index << "\t" << "-" << "\t" << "0M" << endl;
				//vec_add_edge("-", "-");
			}
		}
		//for(KmerVec& v : _dbg_edges_prefix[vec.suffix().normalize()]){
		//	output_file_gfa << "L" << "\t" << vec_id.second << "\t" << "+" << "\t" << _dbg_nodes[v] << "\t" << "+" << "\t" << "0M" << endl;
		//}
	}

	output_file_gfa.close();
	
	cout << "Nb nodes: " << mdbg_errorFree->_dbg_nodes.size() << endl;
	cout << "Nb edges: " << nbEdges << endl;
	
	mdbg_errorFree->dump(_outputDir + "/mdbg_nodes.gz");
	mdbg_errorFree->_dbg_nodes.clear();
	mdbg_errorFree->_dbg_edges.clear();


	string command = "python3 ~/workspace/scripts/assembly/simplify_gfa.py " + gfa_filename;
	int ret = system(command.c_str());
	if(ret != 0){
		cout << "ERROR IN GFA TOOLS" << endl;
		exit(ret);
	}

	createGroundTruth();
}

void Bloocoo::createGroundTruth(){

	string gfa_filename = _outputDir + "/minimizer_graph_notips_nobubbles.gfa";
	cout << gfa_filename << endl;
	gzFile file_readData = gzopen(_filename_readMinimizers.c_str(),"rb");

	ofstream file_groundTruth(_outputDir + "/groundtruth.csv");
	file_groundTruth << "Name,Colour" << endl;

	MDBG* mdbg = new MDBG(_kminmerSize);
	mdbg->load(_outputDir + "/mdbg_nodes.gz");

	vector<u_int32_t> node_to_unitig(mdbg->_dbg_nodes.size(), 0);
	GfaParser gfaParser;
	AdjGraph* graph = gfaParser.createGraph(gfa_filename, node_to_unitig);


	ReadIndexType readIndex = 0;

	unordered_set<u_int32_t> processedUnitigs;

	while(true){

		u_int16_t size;
		vector<u_int64_t> minimizers;
		gzread(file_readData, (char*)&size, sizeof(size));

		if(gzeof(file_readData)) break;
		
		minimizers.resize(size);
		gzread(file_readData, (char*)&minimizers[0], size * sizeof(u_int64_t));

		
		vector<KmerVec> kminmers;

		vector<u_int32_t> datasets;

		int i_max = ((int)minimizers.size()) - (int)_kminmerSize;
		for(int i=0; i<i_max; i++){

			KmerVec vec;

			for(int j=i; j<i+_kminmerSize; j++){
				vec._kmers.push_back(minimizers[j]);
			}
			
			if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;
			
			kminmers.push_back(vec);
			//kminmers.push_back(vec.normalize());

			u_int32_t dataset = _evaluation_readToDataset[readIndex];
			if(std::find(datasets.begin(), datasets.end(), dataset) != datasets.end()) continue;
			
			datasets.push_back(dataset);
		}

		for(KmerVec& vec : kminmers){

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];

			if(processedUnitigs.find(unitigIndex) != processedUnitigs.end()) continue;

			processedUnitigs.insert(unitigIndex);

			//if(unitigIndex == 14) cout << "allo" << endl;
			//cout << kminmer_index << " " << unitigIndex << endl;

			string unitigName = "utg";
			string unitig_name_id = to_string(unitigIndex+1);
			size_t nbZeros = 7 - unitig_name_id.size();
			//cout << unitigIndex << " " << nbZeros << endl;
			for(size_t i=0; i<nbZeros; i++){
				unitigName += "0";
			}
			unitigName += unitig_name_id + "l";

			if(datasets.size() == 0){
				file_groundTruth << unitigName << "," << -2 << endl;
			}
			else if(datasets.size() == 1){
				file_groundTruth << unitigName << "," << datasets[0] << endl;
			}
			else{
				file_groundTruth << unitigName << "," << -1 << endl;
			}

			//size_t nbZeros = utg0000001l
		}

		/*
		vector<ReadIndexType> unitigIndexex;

		for(KmerVec& vec : kminmers){
			if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];

			if(std::find(unitigIndexex.begin(), unitigIndexex.end(), unitigIndex) != unitigIndexex.end()) continue;

			unitigIndexex.push_back(unitigIndex);
		}

		if(unitigIndexex.size() <= 1) continue;

		for(KmerVec& vec : kminmers){
			if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];

			UnitigData& unitigData = unitigDatas[unitigIndex];
			
			if(std::find(unitigData._readIndexes.begin(), unitigData._readIndexes.end(), readIndex) != unitigData._readIndexes.end()) continue;
				
			unitigData._readIndexes.push_back(readIndex);
			//if(std::find(unitigIndexex.begin(), unitigIndexex.end(), unitigIndex) != unitigIndexex.end()) continue
			//unitigIndexex.push_back(unitigIndex);

		}
		*/
		readIndex += 1;
	}

	delete mdbg;
	file_groundTruth.close();
}


void Bloocoo::execute_binning(){
	string gfa_filename = _inputDir + "/minimizer_graph_notips_nobubbles.gfa";
	string mdbg_filename = _inputDir + "/mdbg_nodes.gz";

	cout << gfa_filename << endl;
	MDBG* mdbg = new MDBG(_kminmerSize);
	mdbg->load(mdbg_filename);

	
	vector<u_int32_t> node_to_unitig(mdbg->_dbg_nodes.size(), 0);
	GfaParser gfaParser;
	AdjGraph* graph = gfaParser.createGraph(gfa_filename, node_to_unitig);
	
	vector<vector<u_int32_t>> components;
	graph->computeConnectedComponents(components);
	
	cout << "Nb connected components: " << components.size() << endl;
	for(size_t i=0; i<components.size(); i++){
		if(components[i].size() > 50){
			cout << i <<": " << components[i].size() << endl;
		}
		//if(components[i].size() == 1) cout << components[i][0] << endl;
	}
	cout << graph->_nbNodes << endl;
	cout << graph->_nbEdges << endl;



	gzFile file_readData = gzopen(_filename_readMinimizers.c_str(),"rb");

	ReadIndexType readIndex = 0;
	vector<UnitigData> unitigDatas;
	for(size_t i=0; i<graph->_nbNodes; i++){
		unitigDatas.push_back({i, {}});
	}

	while(true){
		
		//cout << readIndex << endl;

		u_int16_t size;
		vector<u_int64_t> minimizers;
		gzread(file_readData, (char*)&size, sizeof(size));

		if(gzeof(file_readData)) break;
		
		minimizers.resize(size);
		gzread(file_readData, (char*)&minimizers[0], size * sizeof(u_int64_t));

		
		vector<KmerVec> kminmers;

		int i_max = ((int)minimizers.size()) - (int)_kminmerSize;
		for(int i=0; i<i_max; i++){

			KmerVec vec;

			for(int j=i; j<i+_kminmerSize; j++){
				vec._kmers.push_back(minimizers[j]);
			}
			kminmers.push_back(vec.normalize());
		}

		vector<ReadIndexType> unitigIndexex;

		for(KmerVec& vec : kminmers){
			if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];

			if(std::find(unitigIndexex.begin(), unitigIndexex.end(), unitigIndex) != unitigIndexex.end()) continue;

			unitigIndexex.push_back(unitigIndex);
		}

		if(unitigIndexex.size() <= 1) continue;

		for(KmerVec& vec : kminmers){
			if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];

			UnitigData& unitigData = unitigDatas[unitigIndex];
			
			if(std::find(unitigData._readIndexes.begin(), unitigData._readIndexes.end(), readIndex) != unitigData._readIndexes.end()) continue;
				
			unitigData._readIndexes.push_back(readIndex);
			//if(std::find(unitigIndexex.begin(), unitigIndexex.end(), unitigIndex) != unitigIndexex.end()) continue
			//unitigIndexex.push_back(unitigIndex);

		}
		
		readIndex += 1;
	}







	ofstream file_groundTruth(_outputDir + "/binning_results.csv");
	file_groundTruth << "Name,Colour" << endl;

	int iter = 0;
	//utg0000256l
	ReadIndexType utg = 33; //255
	stack<ReadIndexType> stack;
	stack.push(utg);

	unordered_set<DbgEdge, hash_pair> isEdgeVisited;

	while (!stack.empty() && iter < 500){
		
		utg = stack.top();
		stack.pop();


		string unitigName = "utg";
		string unitig_name_id = to_string(utg+1);
		size_t nbZeros = 7 - unitig_name_id.size();
		//cout << unitigIndex << " " << nbZeros << endl;
		for(size_t i=0; i<nbZeros; i++){
			unitigName += "0";
		}
		unitigName += unitig_name_id + "l";

		cout << "Visit node: " << unitigName << endl;

		//cout << unitigName << endl;
		file_groundTruth << unitigName << "," << "red" << endl;




		adjNode* node = graph->_nodes[utg];
		vector<UnitigEdgeScore> unitigScores;

        while (node != nullptr) {
			
			ReadIndexType utg_n = node->val;
			if(isEdgeVisited.find({utg, utg_n}) != isEdgeVisited.end() || isEdgeVisited.find({utg_n, utg}) != isEdgeVisited.end()) {	
				node = node->next;
				continue;
			}

			unitigScores.push_back({utg, utg_n, computeSharedReads(unitigDatas[utg], unitigDatas[utg_n])});

			node = node->next;
        }

		if(unitigScores.size() == 0) continue;

		std::sort(unitigScores.begin(), unitigScores.end(), UnitigEdgeScoreComparator);

		UnitigEdgeScore& bestEdge = unitigScores[0];

		isEdgeVisited.insert({bestEdge._from, bestEdge._to});
		isEdgeVisited.insert({bestEdge._to, bestEdge._from});

		for(size_t i=0; i<unitigScores.size(); i++) {
			cout << unitigScores[i]._from << " " << unitigScores[i]._to << " " <<  unitigScores[i]._score << endl;
			if(unitigScores[i]._score == 0) continue;
			stack.push(unitigScores[i]._to);
		}

		//if(bestEdge._score == 0) continue;



		iter += 1;

		/*
        while (node != nullptr) {
			
			ReadIndexType utg_n = node->val;
			
			//DbgEdge edge = {utg, utg_n};
			if(isEdgeVisited.find({utg, utg_n}) != isEdgeVisited.end() || isEdgeVisited.find({utg_n, utg}) != isEdgeVisited.end()) {	
				node = node->next;
				continue;
			}
			
			string unitigName = "utg";
			string unitig_name_id = to_string(utg_n+1);
			size_t nbZeros = 7 - unitig_name_id.size();
			//cout << unitigIndex << " " << nbZeros << endl;
			for(size_t i=0; i<nbZeros; i++){
				unitigName += "0";
			}
			unitigName += unitig_name_id + "l";

			cout << unitigName << endl;
			file_groundTruth << unitigName << "," << "red" << endl;

			iter += 1;
			
			stack.push(utg_n);

			isEdgeVisited.insert({utg, utg_n});
			isEdgeVisited.insert({utg_n, utg});
			node = node->next;
        }
		*/

		/*
		if (discovered[v]) {
			continue;
		}

		discovered[v] = true;
		cout << v << " ";

		for (auto it = graph.adjList[v].rbegin(); it != graph.adjList[v].rend(); it++)
		{
			int u = *it;
			if (!discovered[u]) {
				stack.push(u);
			}
		}
		*/
	}
	

	file_groundTruth.close();
	/*
	for(UnitigData& unitigData : unitigDatas){
		cout << "------------- " << unitigData._index << endl;
		for(ReadIndexType readIndex : unitigData._readIndexes){
			cout << readIndex << " ";
		}
		cout << endl;
	}
	*/
}






















































































void Bloocoo::execute_binning_cleanGraph(){
	string gfa_filename = _inputDir + "/minimizer_graph_unitigs.gfa";
	string mdbg_filename = _inputDir + "/mdbg_nodes.gz";

	cout << gfa_filename << endl;
	MDBG* mdbg = new MDBG(_kminmerSize);
	mdbg->load(mdbg_filename);

	vector<u_int32_t> unitigLengths;
	vector<int32_t> node_to_unitig(mdbg->_dbg_nodes.size(), -1);
	GfaParser gfaParser;
	UnitigGraph* graph = gfaParser.createGraph(gfa_filename, node_to_unitig, unitigLengths);
	
	cout << "Nb nodes: " << (graph->_nbNodes/2) << endl;
	cout << "Nb edges: " << graph->_nbEdges << endl;




	BiGraph* graph_bi = gfaParser.createBiGraph_lol(_inputDir + "/minimizer_graph_notips_nobubbles.gfa", true);
	














	
	load_read_compositions();
	//load_filtered_minimizers();



	
	
	gzFile file_readData = gzopen(_filename_readMinimizers.c_str(),"rb");

	ReadIndexType readIndex = 0;
	_unitigDatas.resize(graph->_nbNodes);
	//vector<UnitigData> unitigDatas;
	//for(size_t i=0; i<graph->_nbNodes; i++){
	//	unitigDatas.push_back({i, {}});
		//unitigDatas[i]._compositionMean.resize(_compositionManager->_compositionVectorSize);
	//}



	/*
	cout << "Collecting truth kminmers" << endl;
	//ofstream file_groundTruth_hifiasm_position(_outputDir + "/groundtruth_hifiasm_position.csv");
	ofstream file_groundTruth_hifiasm(_outputDir + "/groundtruth_hifiasm.csv");
	file_groundTruth_hifiasm << "Name,Colour" << endl;
	//file_groundTruth_hifiasm_position << "Name,Colour" << endl;

	unordered_set<u_int32_t> groundTruth_kminmers;
	unordered_set<u_int32_t> groundTruth_unitig;
	int founded = 0;
	for(auto it : mdbg->_dbg_nodes){
		//for(auto it : _evaluation_hifiasmGroundTruth){

		const KmerVec& vec = it.first;

		u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
		u_int32_t unitigIndex = node_to_unitig[kminmer_index];
		if(unitigIndex == -1) continue;

		unitigDatas[unitigIndex]._nbKminmers += 1;
		unitigDatas[unitigIndex]._meanAbundance += mdbg->_dbg_nodes[vec]._abundance;



		//vec = vec.normalize();
		if(_evaluation_hifiasmGroundTruth.find(vec) == _evaluation_hifiasmGroundTruth.end()) continue;
		//if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;


		groundTruth_kminmers.insert(kminmer_index);
		founded += 1;


		groundTruth_unitig.insert(unitigIndex);
		file_groundTruth_hifiasm << gfaParser.unitigIndex_to_unitigName(unitigIndex) << "," << _evaluation_hifiasmGroundTruth[vec] << endl;
		//file_groundTruth_hifiasm_position << unitigIndex << "," << _evaluation_hifiasmGroundTruth_position[vec] << endl;

		vector<u_int32_t> neighbors;
		graph->collectNeighbors(unitigIndex, 100, neighbors, 100);
		for(u_int32_t nn : neighbors){
			//cout << nn << endl;
			groundTruth_kminmers.insert(nn);
			groundTruth_unitig.insert(nn);
			//unitigDatas[nn]._nbKminmers += 1;
			//unitigDatas[nn]._meanAbundance += mdbg->_dbg_nodes[vec]._abundance;
			//u_int32_t unitigIndex = node_to_unitig[nn];
			//if(unitigIndex == -1) continue;
			//groundTruth_unitig.insert(unitigIndex);
		}

		
		//cout << founded << endl;
		//cout << "n: " << neighbors.size() << endl;
		//cout << n << endl;


		cout << groundTruth_kminmers.size() << endl;
	}

	for(UnitigData& data : unitigDatas){
		if(data._nbKminmers != 0){
			data._meanAbundance /= data._nbKminmers;
		}
	}
	cout << "Nb nodes abundant: " << groundTruth_kminmers.size() << endl;
	cout << "Founded: " << founded << endl;
	gfaParser.rewriteGfa_withUnitigs(gfa_filename, gfa_filename + "_groundTruth_hifiasm.gfa", groundTruth_unitig, unitigDatas);
	cout << "endo" << endl;
	file_groundTruth_hifiasm.close();
	//file_groundTruth_hifiasm_position.close();
	*/


	while(true){
		
		//cout << readIndex << endl;

		u_int16_t size;
		vector<u_int64_t> minimizers;
		gzread(file_readData, (char*)&size, sizeof(size));

		if(gzeof(file_readData)) break;
		
		minimizers.resize(size);
		gzread(file_readData, (char*)&minimizers[0], size * sizeof(u_int64_t));


		vector<KmerVec> kminmers; 
		MDBG::getKminmers(_kminmerSize, minimizers, kminmers);

		vector<ReadIndexType> unitigIndexex;

		for(KmerVec& vec : kminmers){
			if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];
			if(unitigIndex == -1) continue;

			/*
			UnitigData& unitigData = unitigDatas[unitigIndex];
			ReadData& readData = _readDatas[readIndex];
			for(size_t i=0; i<readData._composition.size(); i++){
				unitigData._compositionMean[i] += readData._composition[i];
			}
			unitigData._compositionNb += 1;
			*/

			//if(groundTruth_unitig.find(unitigIndex) == groundTruth_unitig.end()) continue;

			//cout << kminmer_index << " " << unitigIndex << endl;
			if(std::find(unitigIndexex.begin(), unitigIndexex.end(), unitigIndex) != unitigIndexex.end()) continue;

			unitigIndexex.push_back(unitigIndex);
			if(unitigIndexex.size() >= 2) break;
		}

		if(unitigIndexex.size() >= 2){
			for(KmerVec& vec : kminmers){
				if(mdbg->_dbg_nodes.find(vec) == mdbg->_dbg_nodes.end()) continue;

				u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
				u_int32_t unitigIndex = node_to_unitig[kminmer_index];
				if(unitigIndex == -1) continue;

				//if(groundTruth_unitig.find(unitigIndex) == groundTruth_unitig.end()) continue;
				//if(groundTruth_unitig.find(unitigIndex) == groundTruth_unitig.end()) continue;

				UnitigData& unitigData = _unitigDatas[unitigIndex];
				
				//if(unitigData._readIndexes_exists.find(readIndex) != unitigData._readIndexes_exists.end()) continue;
				//cout << unitigData._readIndexes.size() << endl;
				//if(std::find(unitigData._readIndexes.begin(), unitigData._readIndexes.end(), readIndex) != unitigData._readIndexes.end()) continue;
					
				//unitigData._readIndexes_exists.insert(readIndex);
				//cout << unitigIndex << " " << unitigData._readIndexes.size() << endl;
				//cout << unitigData._readIndexes.size() << endl;
				unitigData._readIndexes.push_back(readIndex);

				//cout << kminmer_index << " " << unitigIndex << " " << unitigData._readIndexes.size() << " " << readIndex << endl;
				//cout << unitigData._readIndexes.size() << " " << unitigLengths[unitigIndex] << endl;
				//if(std::find(unitigIndexex.begin(), unitigIndexex.end(), unitigIndex) != unitigIndexex.end()) continue
				//unitigIndexex.push_back(unitigIndex);

			}
		}


		
		readIndex += 1;
	}

	/*
	for(UnitigData& data : unitigDatas){
		for(size_t i=0; i<data._compositionMean.size(); i++){
			data._compositionMean[i] /= data._compositionNb;
		}

	}
	*/




	//solveBin(GfaParser::unitigName_to_id("utg0000804l"), graph);
	

	//solveBin(GfaParser::unitigName_to_id("utg0000805l"), graph, unitigDatas, file_groundTruth, 1);

	///home/gats/workspace/run/hifiasm_meta/AD_components/component_5.fasta
	//solveBin(GfaParser::unitigName_to_id("utg0437330l"), graph, unitigDatas, file_groundTruth, 1);
	
	///home/gats/workspace/run/hifiasm_meta/AD_components/component_6.fasta
	//solveBin(GfaParser::unitigName_to_id("utg0459582l"), graph, unitigDatas, file_groundTruth, 1);


	///home/gats/workspace/run/hifiasm_meta/AD_components/component_5.fasta
	//solveBin(721346, graph, unitigDatas, file_groundTruth, 1);

	///home/gats/workspace/run/hifiasm_meta/AD_components/component_6.fasta
	//solveBin(1057286, graph, unitigDatas, file_groundTruth, 1);

	///home/gats/workspace/run/hifiasm_meta/AD_components/component_8.fasta
	//solveBin(GfaParser::unitigName_to_id("utg0198809l"), graph, unitigDatas, file_groundTruth, 1, binNodes);

	///home/gats/workspace/run/hifiasm_meta/AD_components/component_9.fasta
	//solveBin(GfaParser::unitigName_to_id("utg0435813l"), graph, unitigDatas, file_groundTruth, 1, binNodes);



	/*
	solveBin(4106, graph, unitigDatas, file_groundTruth, 1);
	solveBin(51899, graph, unitigDatas, file_groundTruth, 2);
	solveBin(95193, graph, unitigDatas, file_groundTruth, 3);
	solveBin(10985, graph, unitigDatas, file_groundTruth, 4);

	solveBin(78693, graph, unitigDatas, file_groundTruth, 5);
	solveBin(92561, graph, unitigDatas, file_groundTruth, 6);
	solveBin(109366, graph, unitigDatas, file_groundTruth, 7);
	solveBin(234177, graph, unitigDatas, file_groundTruth, 8);
	solveBin(143694, graph, unitigDatas, file_groundTruth, 9);
	solveBin(25798, graph, unitigDatas, file_groundTruth, 10);
	*/


	//solveBin(GfaParser::unitigName_to_id("utg0000799l"), graph);

	ofstream file_groundTruth(_outputDir + "/binning_results.csv");
	file_groundTruth << "Name,Colour" << endl;
	unordered_set<u_int32_t> binNodes;
	//TODO
	file_groundTruth.close();

	
	/*
	cout << "Writing gfa" << endl;

	unordered_set<u_int32_t> unitigs;
	for(auto it : mdbg->_dbg_nodes){

		const KmerVec& vec = it.first;

		u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
		u_int32_t unitigIndex = node_to_unitig[kminmer_index];
		if(unitigIndex == -1) continue;


		if(binNodes.find(unitigIndex) == binNodes.end()) continue;
		unitigs.insert(unitigIndex);

		vector<u_int32_t> neighbors;
		graph->collectNeighbors(unitigIndex, 100, neighbors, 100);
		for(u_int32_t nn : neighbors){
			unitigs.insert(nn);
		}

	}
	gfaParser.rewriteGfa_withUnitigs(gfa_filename, gfa_filename + "_binResults.gfa", unitigs, unitigDatas);
	*/
	//file_groundTruth_hifiasm_position.close();



	/*
	unordered_set<DbgEdge, hash_pair> unsupportedEdges;

	for(size_t utg=0; utg<graph->_nbNodes; utg++){

		//cout << utg << " " << graph->_nbNodes << endl;

		adjNode* node = graph->_nodes[utg];

        while (node != nullptr) {
			
			ReadIndexType utg_n = node->val;

			//cout << utg << " " << utg_n << " " << unitigDatas[utg]._readIndexes.size() << " " << unitigDatas[utg_n]._readIndexes.size() << endl;

			if(unsupportedEdges.find({utg, utg_n}) != unsupportedEdges.end() || unsupportedEdges.find({utg_n, utg}) != unsupportedEdges.end()) {	
				node = node->next;
				continue;
			}

			if(shareAnyRead(unitigDatas[utg], unitigDatas[utg_n])){
				node = node->next;
				continue;
			}

			//if(shareAnyRead(unitigDatas[utg], unitigDatas[utg_n])){
			unsupportedEdges.insert({utg, utg_n});
			unsupportedEdges.insert({utg_n, utg});
			//}

			node = node->next;
        }

	}

	cout << "Nb unsupported edges: " << unsupportedEdges.size() << endl;

	gfaParser.rewriteGfa_withoutEdges(gfa_filename, gfa_filename +"_2.gfa", unsupportedEdges);



	delete graph;
	node_to_unitig.clear();
	unitigLengths.clear();
	components.clear();
	graph = gfaParser.createGraph(gfa_filename +"_2.gfa", node_to_unitig, unitigLengths);
	
	cout << "Nb nodes: " << graph->_nbNodes << endl;
	cout << "Nb edges: " << graph->_nbEdges << endl;

	graph->computeConnectedComponents(components);

	cout << endl << "Nb connected components: " << components.size() << endl;
	for(size_t i=0; i<components.size(); i++){

		u_int64_t component_size_nt = 0;
		for(u_int32_t utg : components[i]){
			component_size_nt += unitigLengths[utg];
		}
		if(component_size_nt > 1000000){
			cout << i <<": " << component_size_nt << endl;
		}
	}
	cout << endl;
	*/

	/*
	ofstream file_groundTruth(_outputDir + "/binning_results.csv");
	file_groundTruth << "Name,Colour" << endl;

	int iter = 0;
	//utg0000256l
	ReadIndexType utg = 33; //255
	stack<ReadIndexType> stack;
	stack.push(utg);

	unordered_set<DbgEdge, hash_pair> isEdgeVisited;

	while (!stack.empty() && iter < 500){
		
		utg = stack.top();
		stack.pop();


		string unitigName = "utg";
		string unitig_name_id = to_string(utg+1);
		size_t nbZeros = 7 - unitig_name_id.size();
		//cout << unitigIndex << " " << nbZeros << endl;
		for(size_t i=0; i<nbZeros; i++){
			unitigName += "0";
		}
		unitigName += unitig_name_id + "l";

		cout << "Visit node: " << unitigName << endl;

		//cout << unitigName << endl;
		file_groundTruth << unitigName << "," << "red" << endl;




		adjNode* node = graph->_nodes[utg];
		vector<UnitigEdgeScore> unitigScores;

        while (node != nullptr) {
			
			ReadIndexType utg_n = node->val;
			if(isEdgeVisited.find({utg, utg_n}) != isEdgeVisited.end() || isEdgeVisited.find({utg_n, utg}) != isEdgeVisited.end()) {	
				node = node->next;
				continue;
			}

			unitigScores.push_back({utg, utg_n, computeSharedReads(unitigDatas[utg], unitigDatas[utg_n])});

			node = node->next;
        }

		if(unitigScores.size() == 0) continue;

		std::sort(unitigScores.begin(), unitigScores.end(), UnitigEdgeScoreComparator);

		UnitigEdgeScore& bestEdge = unitigScores[0];

		isEdgeVisited.insert({bestEdge._from, bestEdge._to});
		isEdgeVisited.insert({bestEdge._to, bestEdge._from});

		for(size_t i=0; i<unitigScores.size(); i++) {
			cout << unitigScores[i]._from << " " << unitigScores[i]._to << " " <<  unitigScores[i]._score << endl;
			if(unitigScores[i]._score == 0) continue;
			stack.push(unitigScores[i]._to);
		}

		//if(bestEdge._score == 0) continue;



		iter += 1;


	}
	

	file_groundTruth.close();
	*/
	/*
	for(UnitigData& unitigData : unitigDatas){
		cout << "------------- " << unitigData._index << endl;
		for(ReadIndexType readIndex : unitigData._readIndexes){
			cout << readIndex << " ";
		}
		cout << endl;
	}
	*/
}


	/*
	vector<u_int32_t> node_to_unitig(mdbg_errorFree->_dbg_nodes.size(), 0);
	GfaParser gfaParser;
	AdjGraph* graph = gfaParser.createGraph("/home/gats/workspace/data/overlap_test/read_overlaps_notips_nobubbles.gfa", node_to_unitig);
	
	vector<vector<u_int32_t>> components;
	graph->computeConnectedComponents(components);
	
	cout << "Nb connected components: " << components.size() << endl;
	for(size_t i=0; i<components.size(); i++){
		if(components[i].size() > 50){
			cout << i <<": " << components[i].size() << endl;
		}
		//if(components[i].size() == 1) cout << components[i][0] << endl;
	}
	*/


	/*
	cout << _overlapGraph->_nbNodes << endl;
	cout << _overlapGraph->_nbEdges << endl;


	
	AdjGraph* minimizerGraph_cleaned = new AdjGraph();
	MinimizerPairMap* _minimizerPairMap_cleaned = new MinimizerPairMap();

	//for (auto& it: minimizerCounts) {
	//	if(it.second <= 1) continue;
	//	if(it.second <= 10) continue;
	//	cout << it.second << endl;
	//}

	for(size_t n=0; n<_overlapGraph->_nbNodes; n++){

		MinimizerPair& pair = _minimizerPairMap->id_to_pair(n);



		if(!checkRemoveNode(n, _overlapGraph, _minimizerPairMap, minimizerCounts)){
			//_overlapGraph->collectNeighbors(n, 1, neighbors);
			//if(minimizerCounts[pair] > 1 && minimizerCounts[pair] < 35){
			_minimizerPairMap_cleaned->addNode(pair);
			bool added = minimizerGraph_cleaned->addNode(_minimizerPairMap_cleaned->pair_to_id(pair));
			if(added){
				//output_file_gfa << "S" << "\t" << _minimizerPairMap->pair_to_id(pair) << "\t" << "*" << "\t" << "LN:i:" << 0 << "\t" << "dp:i:" << minimizerCounts[pair] << endl;
			}
		}


		adjNode* node = _overlapGraph->_nodes[n];

        while (node != nullptr) {
			
			u_int32_t nn = node->val;
			MinimizerPair& pair_nn = _minimizerPairMap->id_to_pair(nn);

			if(!checkRemoveNode(nn, _overlapGraph, _minimizerPairMap, minimizerCounts)){
				//if(minimizerCounts[pair_nn] > 1 && minimizerCounts[pair_nn] < 35){
				_minimizerPairMap_cleaned->addNode(pair_nn);
				bool added = minimizerGraph_cleaned->addNode(_minimizerPairMap_cleaned->pair_to_id(pair_nn));
				if(added){
					//output_file_gfa << "S" << "\t" << _minimizerPairMap->pair_to_id(pair_nn) << "\t" << "*" << "\t" << "LN:i:" << 0 << "\t" << "dp:i:" << minimizerCounts[pair_nn] << endl;
				}

				added = minimizerGraph_cleaned->addEdge_checkDuplicate(_minimizerPairMap_cleaned->pair_to_id(pair), _minimizerPairMap_cleaned->pair_to_id(pair_nn), 0);
				if(added){
					//output_file_gfa << "L" << "\t" << _minimizerPairMap->pair_to_id(pair) << "\t" << "+" << "\t" << _minimizerPairMap->pair_to_id(pair_nn) << "\t" << "+" << "\t" << "0M" << endl;
				}

			}

			node = node->next;
        }

	}

	cout << minimizerGraph_cleaned->_nbNodes << endl;
	cout << minimizerGraph_cleaned->_nbEdges << endl;

	output_file_gfa.close();
	*/

	/*
	vector<float> dists;
	for(size_t n=0; n<_readData.size(); n++){
		

		for(size_t nn=n+1; nn<_readData.size(); nn++){
			float dist = computeDistanceTNF(_readData[n], _readData[nn]);

			//cout << dist << endl;
			
			dists.push_back(dist);

		}
	}

	print_stats(dists);
	*/
	
	//cout << nbMinimizers << endl;

	/*
	u_int64_t processed = 0;

	vector<vector<u_int16_t>> readCoverages(readIndex);
	unordered_map<MinimizerPair, u_int16_t> readPairCount;

	cout << minimizerPairs_to_reads.size() << endl;

	for (auto& it: minimizerPairs_to_reads) {

		processed += 1;
		if(processed % 100000 == 0){
			float progress = ((float) processed) / minimizerPairs_to_reads.size();
			//cout << progress << endl;
		} 


		MinimizerPair minimizerPair = it.first;
		vector<u_int32_t>& readIds = it.second;



		//u_int32_t m1 = (u_int32_t)((minimizerPair & 0xFFFFFFFF00000000LL) >> 32);
		//u_int32_t m2 = (u_int32_t)(minimizerPair & 0xFFFFFFFFLL);
		//cout << "Read pair: " << m1 << " " << m2 << " " << minimizerPair << endl;

		//cout << readIds.size() << endl;
		//cout << "------------" << endl;
		//for(size_t k=0; k<readIds.size(); k++) {
		//	cout << readIds[k] << endl;
		//}



		if(readIds.size() == 1) continue;

		//cout << readIds.size() << endl;
		if(readIds.size() > 10000) continue;

		//cout << readIds.size() << endl;
		for(size_t i=0; i<readIds.size(); i++) {
			
				//cout << i << " " << readIds.size() << endl;

			u_int32_t read1 = readIds[i];

			//if(read1 == 9363) cout << "Reads: " << readIds.size() << endl; 

			for(size_t j=i+1; j<readIds.size(); j++) {

				u_int32_t read2 = readIds[j];
				//if(read2 == 9363) cout << "Reads: " << readIds.size() << endl; 


				//if ((read1 == 7721 && read2 == 9442) || read2 == 7721 && read1 == 9442) {
					//cout << "lala" << endl;
				//}

				//cout << read1 << " " << read2 << endl;

				if(read1 == read2){
					//cout << "------------" << endl;
					//for(size_t k=0; k<readIds.size(); k++) {
						//cout << readIds[k] << endl;
					//}
					continue;
				}

				float dist = computeDistanceTNF(_readData[read1], _readData[read2]);
				//float t = 0.01f + 
				if(dist > 0.6f){
					//cout << read1 << " " << read2 << " " << dist << endl;
					continue;
				}

				

				


				//if(_evaluation_readToDataset[read1] != _evaluation_readToDataset[read2]){
				//	cout << "Diff dataset: " << computeDistanceTNF(_readData[read1], _readData[read2]) << endl;
				//}
				//else{
				//	cout << "Same dataset: " << computeDistanceTNF(_readData[read1], _readData[read2]) << endl;
				//}

				MinimizerPair readPair = {read1, read2};
				//u_int64_t readPair = (u_int64_t) read1 << 32 | read2;

				if(readPairCount.find(readPair) == readPairCount.end()){
					//cout << "Overlap: " << read1 << " " << read2 << endl;
					readPairCount[readPair] = 0;
					//cout << readPairCount.size() << endl;
				}

				readPairCount[readPair] += 1;


				//if ((readPair._first == 7721 && read2 == 9442) || read2 == 7721 && read1 == 9442) {
					//cout << readPairCount[readPair] << endl;
				//}

				//cout << j << endl;

			}
		}

		
		//cout << "Reads: " << readIds.size() << endl;


	}


	*/
	/*
	for(size_t i=0; i<readCoverages.size(); i++){
		if(read_headers[i] == "G3_0 S1_1"){

			for(size_t cov : readCoverages[i]){
				cout << cov << endl;
			}

			float mean = 0;
			
			for(size_t cov : readCoverages[i]){
				mean += cov;
			}
			mean /= readCoverages[i].size();

			float var = 0;
			for(size_t cov : readCoverages[i]){
				var += pow((cov - mean), 2);
			}
			var /= (readCoverages[i].size() - 1);
			float sd = SQRT(var);
			
			cout << "Mean: " << mean << endl;
			cout << "Sd: " << sd << endl;
			cout << "Var: " << var << endl;

		}
	}
	*/

	/*
	set<u_int32_t> nodes;


	//vector<u_int32_t> nodes;

	//ofstream output_file("/home/gats/workspace/data/overlap_test/read_overlaps.txt");
	ofstream output_file_gfa("/home/gats/workspace/data/overlap_test/read_overlaps.gfa");

	u_int64_t nbOverlaps = 0;

	u_int64_t nbOverlaps_interGenomes = 0;

	
	//u_int64_t nbNodes = 0;
	for (auto& it: readPairCount) {
		u_int16_t count = it.second;
		//if(count <= 1) continue;


		MinimizerPair readPair = it.first;
		u_int32_t read1 = readPair._first;//(u_int32_t)((readPair & 0xFFFFFFFF00000000LL) >> 32);
		u_int32_t read2 = readPair._second;//(u_int32_t)(readPair & 0xFFFFFFFFLL);

		nodes.insert(read1);
		nodes.insert(read2);
		//nbNodes += 1;
	}
	
	GraphInfo* graphInfo = new GraphInfo();

	cout << "Nb nodes: " << nodes.size() << endl;
	//cout << readIndex << " " << nbNodes << endl;
	//u_int64_t nbNodes = readIndex;
	_overlapGraph = new AdjGraph(nodes.size());

	vector<Overlap> overlaps;

	int nbOverlapsLala = 0;
	for (auto& it: readPairCount) {
		
		u_int16_t count = it.second;
		if(count <= 1) continue;


		MinimizerPair readPair = it.first;

		u_int32_t read1 = readPair._first;//(u_int32_t)((readPair & 0xFFFFFFFF00000000LL) >> 32);
		u_int32_t read2 = readPair._second;//(u_int32_t)(readPair & 0xFFFFFFFFLL);

		overlaps.push_back({read1, read2, count});


		//if(read1 == read2) cout << "rofl " << read1 << endl;


		if(read1 == 9363 || read2 == 9363){
			nbOverlapsLala += 1;
			//cout << "ReadPairCount: " << nbOverlapsLala << " " << count << endl; 
		}


		//float dist = computeDistanceTNF(_readData[read1], _readData[read2]);
		//float t = 0.01f + count * 0.005f;
		//if(dist > t) continue; //To remove I think

		if(_evaluation_readToDataset[read1] != _evaluation_readToDataset[read2]){
			nbOverlaps_interGenomes += 1;
			//float dist = computeDistanceTNF(_readData[read1], _readData[read2]);
			//cout << "Bad overlaps: " <<  read1 << " " << read2 << " " << count << " " << dist << endl;
		}

		//if ((read1 == 7721 && read2 == 9442) || read2 == 7721 && read1 == 9442) {
			//cout << read_headers[read1] << " " << read_headers[read2] << endl;
		//}


		//if(read1 == 101) cout << _readData[read1]._graphVertex << endl;
		//if(read2 == 101) cout << _readData[read2]._graphVertex << endl;


		//output_file << read_headers[read1] << ";" << read_headers[read2] << ";" << count << endl; //!

		//cout << read1 << " " << read2 << " " << count << " " << (_evaluation_readToDataset[read1] == _evaluation_readToDataset[read2]) << endl;
		//if(!_readData[read1]._vertexCreated){
		//	_readData[read1]._vertexCreated = true;
			//nodes.push_back(read1);
			//boost::adjacency_list<>::vertex_descriptor v1 = boost::add_vertex(_overlapGraph);
			//_readData[read1]._graphVertex = v1;
			//_overlapGraph[v1]._readIndex = read1;

			//cout << "Create node: " << v1 << " " << read1 << endl;
			//if(read1 == 101) cout << "Added " << v1 << endl;

		//}
		//if(!_readData[read2]._vertexCreated){
		//	_readData[read2]._vertexCreated = true;
			//nodes.push_back(read2);
			//boost::adjacency_list<>::vertex_descriptor v1 = boost::add_vertex(_overlapGraph);
			//_readData[read2]._graphVertex = v1;
			//_overlapGraph[v1]._readIndex = read2;
			
			//cout << "Create node: " << v1 << " " << read2 << endl;
			//if(read2 == 101) cout << "Added " << v1 << endl;
		//}

		//if(read1 > nbNodes || read2 > nbNodes) cout << "allo" << endl;

		graphInfo->addNode(read1);
		graphInfo->addNode(read2);

		_overlapGraph->addEdge(graphInfo->readIndex_to_id(read1), graphInfo->readIndex_to_id(read2), 0);
		//cout << read1 << " " << read2 << " " << nbNodes << endl;

		//boost::add_edge(_readData[read1]._graphVertex, _readData[read2]._graphVertex, _overlapGraph);

		//output_file_gfa << "L" << "\t" << read1 << "\t" << "+" << "\t" << read2 << "\t" << "+" << "\t" << "0M" << endl;

		nbOverlaps += 1;

	}

	//vector<bool> hasMatch(readIndex, false);
	unordered_map<ReadIndexType, vector<ReadIndexType>> bestOverlaps;
	unordered_map<ReadIndexType, vector<ReadIndexType>> bestOverlaps_reverse;
	//cout << "----" << endl;
	std::sort(overlaps.begin(), overlaps.end(), OverlapComparator);
	for(Overlap& overlap : overlaps){

		ReadIndexType read1 = overlap._r1;
		ReadIndexType read2 = overlap._r2;


		if(bestOverlaps.find(read1) == bestOverlaps.end() && bestOverlaps_reverse.find(read2) == bestOverlaps_reverse.end()){

			bool isCycle = false;
			ReadIndexType currentRead = read1;
			while(true){

				if(bestOverlaps_reverse.find(currentRead) == bestOverlaps_reverse.end()) break;

				currentRead = bestOverlaps_reverse[currentRead];
				if(currentRead == read2){
					isCycle = true;
					break;
				}
			}

			if(!isCycle){
				bestOverlaps[read1] = read2;
				bestOverlaps_reverse[read2] = read1;
				continue;
			}
			
		}
		
		if(bestOverlaps.find(read2) == bestOverlaps.end() && bestOverlaps_reverse.find(read1) == bestOverlaps_reverse.end()){

			bool isCycle = false;
			ReadIndexType currentRead = read2;
			while(true){

				if(bestOverlaps_reverse.find(currentRead) == bestOverlaps_reverse.end()) break;
				currentRead = bestOverlaps_reverse[currentRead];
				if(currentRead == read1){
					isCycle = true;
					break;
				}
			}

			if(!isCycle){
				bestOverlaps[read2] = read1;
				bestOverlaps_reverse[read1] = read2;
			}
			
		}
		
		



		//else if(bestOverlaps.find(read2) == bestOverlaps.end()){
		//	bestOverlaps[read2] = read1;
		//	hasMatch[read1] = true;
		//}


		//cout << "Overlap: " << overlap._nbMinimizers << endl;
	}

	for (auto& it: bestOverlaps) {
		
		u_int32_t read1 = it.first;//(u_int32_t)((readPair & 0xFFFFFFFF00000000LL) >> 32);
		u_int32_t read2 = it.second;//(u_int32_t)(readPair & 0xFFFFFFFFLL);
		output_file_gfa << "L" << "\t" << read1 << "\t" << "+" << "\t" << read2 << "\t" << "+" << "\t" << "0M" << endl;
	}
	//for(size_t i=0; i<_readData.size(); i++){
	//	if(_readData[i]._composition.size() == 0) continue;
	//	output_file_gfa << "L" << "\t" << i << "\t" << "+" << "\t" << _readData[i]._readBestMatch << "\t" << "+" << "\t" << "0M" << endl;
	//}
	
	for(u_int32_t node : nodes){
		output_file_gfa << "S" << "\t" << node << "\t" << "*" << "\t" << "LN:i:" << _readData[node]._length << endl;
	}

	output_file_gfa.close();
	nodes.clear();

	cout << "Nb overlaps: " <<  nbOverlaps << endl;
	cout << "Nb overlaps inter genomes: " <<  nbOverlaps_interGenomes << endl;

	*/
	/*
	//_overlapGraph->display_AdjList(0, graphInfo);
	cout << "--------" << endl;
	vector<u_int32_t> neighbors;
	_overlapGraph->collectNeighbors(0, 2, neighbors);
	for(u_int32_t n : neighbors){
		cout << n << endl;
	}

	set<u_int32_t> lala;
	cout << "--------" << endl;
	_overlapGraph->collectNeighbors(0, 1, neighbors);
	for(u_int32_t n : neighbors){
		lala.insert(n);
		vector<u_int32_t> neighbors2;
		_overlapGraph->collectNeighbors(n, 1, neighbors2);
		for(u_int32_t nn : neighbors2){
			lala.insert(nn);
		}
	}

	for(auto lalala : lala){
		cout << lalala << endl;
	}

	//output_file.close();

	//_overlapGraph->display_AdjList(0);
	*/
	/*
	cout << "Nb nodes: " << boost::num_vertices(_overlapGraph) << endl;

	std::vector<int> component (boost::num_vertices (_overlapGraph));
	size_t num_components = boost::connected_components (_overlapGraph, &component[0]);
	cout << "Nb components: " << num_components << endl;

	vector<vector<ReadIndexType>> readPerCompoenents(num_components);
	vector<u_int64_t> nbNodePerComponents(num_components, 0);

	for (size_t i = 0; i < boost::num_vertices (_overlapGraph); i++){
		nbNodePerComponents[component[i]] += 1;

		readPerCompoenents[component[i]].push_back(_overlapGraph[i]._readIndex);
		//cout <<  "Node: " << i << " Read: " << graph[i]._readIndex << endl;
	}
	
	for(size_t i=0; i<num_components; i++){
		if(nbNodePerComponents[i] < 100) continue;
		cout << "Compoenents " << i << ": " << nbNodePerComponents[i] << endl;
	}

	cout << "Nb components: " << num_components << endl;
	*/
	/*
	for(size_t i=0; i<readPerCompoenents.size(); i++){
		cout << "---------------- " << i << endl;
		for(ReadIndexType ri : readPerCompoenents[i]){
			cout << _evaluation_readToDataset[ri] << endl;
		}
	}
	*/

	//createSimilarityGraph(graphInfo);


/*
static void writeGfa(AdjGraph* graph, const string& outputFilename){

        cout << "Dumping graph: " << outputFilename << endl;

        //cout << graph->_nbNodes << endl;
	    vector<u_int64_t> neighbors;

	    ofstream outputFile(outputFilename);

        for(size_t n=0; n<graph->_nbNodes; n++){
            //if(graph->_nodes[n]->isBidirection) continue;

            //cout << n << " " << graph->_graphInfo->_unitigs_length.size() << endl;
            outputFile << "S" << "\t" << n << "\t" << "*" << "\t" << "LN:i:" << graph->_graphInfo->_unitigs_length[n] << endl;


            adjNode* node = graph->_nodes[n];
            while (node != nullptr) {

                if(node->isBidirection){
                    node = node->next;
                    continue;
                }

                string from = "";
                if(node->directionFrom) from = "+"; else from = "-";

                string to = "";
                if(node->directionTo) to = "+"; else to = "-";

                outputFile << "L" << "\t" << n << "\t" << from << "\t" << node->val << "\t" << to << "\t" << "0M" << endl;

                node = node->next;

            }


        }

        outputFile.close();
    }

*/



/*
void Bloocoo::createSimilarityGraph(GraphInfo* graphInfo){


	
	ofstream stats_file("/home/gats/workspace/run/histos/binner_stats.csv");
	ofstream graph_output_file("/home/gats/workspace/run/histos/similarityGraph.txt");


	u_int64_t nbEdgeIntra = 0;
	u_int64_t nbEdgeInter = 0;

	vector<float> distTNF_intra;
	vector<float> distTNF_inter;
	vector<u_int32_t> neighbors;

	u_int64_t nbEdges = 0;

	for(size_t n=0; n<_overlapGraph->_nbNodes; n++){

		ReadIndexType read = graphInfo->id_to_readIndex(n);
		//ReadIndexType read = _overlapGraph[n]._readIndex;
		u_int32_t read_datasetId = _evaluation_readToDataset[read];

		//cout << n << " " << read << endl;
		_overlapGraph->collectNeighbors(n, 10, neighbors);

		//cout << "------" << endl;
		//auto neighbours = boost::adjacent_vertices(n, _overlapGraph);
		//for (auto nn : make_iterator_range(neighbours)){

		for (u_int64_t nn : neighbors){

			//cout << nn << endl;
			//ReadIndexType read_neighbor = _overlapGraph[nn]._readIndex;
			ReadIndexType read_neighbor = graphInfo->id_to_readIndex(nn);
			u_int32_t read_neighbor_datasetId = _evaluation_readToDataset[read_neighbor];

			

			float dist = computeDistanceTNF(_readData[read], _readData[read_neighbor]);

			//if(n == 0){
				//cout << dist << endl;
			//}
			if(read_datasetId == read_neighbor_datasetId){
				nbEdgeIntra += 1;
				distTNF_intra.push_back(dist);
				//cout << dist << endl;
			}
			else{
				nbEdgeInter += 1;
				distTNF_inter.push_back(dist);
				//cout << dist << endl;
			}
			
			if(dist > 0.05) continue;
			

			float weight = 1.0 - dist;
			graph_output_file << read << " " << read_neighbor << " " << weight << endl;
			nbEdges += 1;

		}
		
	}
	
	cout << "Nb edges total: " << nbEdges << endl;
	cout << "Nb edges intra: " << nbEdgeIntra << endl;
	cout << "Nb edges inter: " << nbEdgeInter << endl;
	cout << "Intra dists:" << endl;
	print_stats(distTNF_intra);
	cout << "Inter dists:" << endl;
	print_stats(distTNF_inter);

	graph_output_file.close();


	stats_file.close();
}
*/




































































	//vector<ReadData> _readDatas;
	//vector<u_int32_t> _nodeAbundances;

	/*
    void collectNeighbors_sharingReads(AdjGraph* graph, u_int32_t utg, const vector<UnitigData>& unitigDatas, vector<u_int32_t>& neighbors, unordered_set<u_int32_t>& binNodes){

		//results.clear();
		unordered_set<u_int32_t> isVisited;
        neighbors.clear();
        //if(_nodes[s] == nullptr) return;

        //neighbors.push_back(s);

        //for(size_t i=0; i<_nbNodes; i++){
        //    isVisited[i] = false;
        //    distance[i] = 0;
            //prev[i] = -1;
        //}

    
        queue<u_int32_t> queue;
    
        //isVisited[s] = true;
        //distance[s] = 0;
        queue.push(utg);
		isVisited.insert(utg);
		//results.insert(utg_n);
    
    
        while(!queue.empty()){
            
            u_int32_t n = queue.front();
            queue.pop();

            adjNode* node = graph->_nodes[n];

            while (node != nullptr) {

                u_int32_t utg_n = node->val;

                if (isVisited.find(utg_n) != isVisited.end()){
                    node = node->next;
                    continue;
                }

				isVisited.insert(utg_n);

				if(!shareAnyRead(unitigDatas[utg], unitigDatas[utg_n])){
                    node = node->next;
                    continue;
				}
                //isVisited[nn] = true;
                //distance[nn] = distance[n] + 1;

				if(binNodes.find(utg_n) == binNodes.end()){
                	neighbors.push_back(utg_n);
				}


                //if(distance[nn] >= maxDistance) continue;

                //cout << "Push: " << nn << " " << distance[nn] << endl;
                queue.push(utg_n);
				//results.insert(utg_n);

                node = node->next;
            }

        }

    }*/

	/*
	void solveBin(u_int32_t utg, AdjGraph* graph, const vector<UnitigData>& unitigDatas, ofstream& file, int color){

		//cout << computeSharedReads(unitigDatas[924320], unitigDatas[924321]) << endl;
		//cout << computeSharedReads(unitigDatas[924328], unitigDatas[924327]) << endl;
		//cout << computeSharedReads(unitigDatas[924328], unitigDatas[4451136]) << endl;

		unordered_set<u_int32_t> binNodes;

		stack<ReadIndexType> stack;
		stack.push(utg);
		binNodes.insert(utg);
		//unordered_set<u_int32_t> isNodeVisisted;
		unordered_map<DbgEdge, float, hash_pair> cache_distanceTnf;
		unordered_set<DbgEdge, hash_pair> isEdgeVisited;





		while (!stack.empty()){
			
			utg = stack.top();
			stack.pop();


		

			file << utg << "," << color << endl;





			vector<u_int32_t> neighbors;
			//unordered_set<u_int32_t> neighborsShar

			//collectNeighbors_sharingReads(graph, utg, unitigDatas, neighbors, binNodes);
			graph->collectNeighbors(utg, 1, neighbors, 0);
			//if(neighbors.size() == 0) continue;

			//cout << "---------------" << endl;
			//cout << utg << endl;

			for(u_int32_t utg_n : neighbors){
			
			
				DbgEdge edge = {utg, utg_n};
				edge = edge.normalize();

				if(isEdgeVisited.find(edge) != isEdgeVisited.end()){
					continue;
				}

				isEdgeVisited.insert(edge);


				
				vector<float> tnf_distances;
				
				for(u_int32_t r1 : unitigDatas[utg]._readIndexes){
					for(u_int32_t r2 : unitigDatas[utg_n]._readIndexes){
						//if(r1 == r2) continue;
						
						DbgEdge readPair = {r1, r2};
						readPair = readPair.normalize();

						float distance_tnf = -1;
						if(cache_distanceTnf.find(readPair) != cache_distanceTnf.end()){
							//cout << "oyo" << endl;
							distance_tnf = cache_distanceTnf[readPair];
						}
						else{
							distance_tnf = computeDistanceTNF(_readDatas[r1], _readDatas[r2]);
							//distance_tnf = euclidianDistance(_readDatas[r1]._composition, _readDatas[r2]._composition);
							cache_distanceTnf[readPair] = distance_tnf;
						}
						
					
						tnf_distances.push_back(distance_tnf);

					}
					
				}

				float median = compute_median_float(tnf_distances);

				if(median > 0.1){
					//float dist = euclidianDistance(unitigDatas[utg]._compositionMean, unitigDatas[utg_n]._compositionMean);
					cout << utg << " " << utg_n << "      " << median << endl;
				}

				
				u_int64_t nbSharedReads = computeSharedReads(unitigDatas[utg], unitigDatas[utg_n]);
				if(nbSharedReads == 0) continue;
				if(nbSharedReads <= 30){
					//if(median > 0.001){
						continue;
					//}
				}

				stack.push(utg_n);
				binNodes.insert(utg_n);
				cout << "Bin nodes: " << binNodes.size() << " " << utg_n << " " << median << endl;
				


			}





		}

		cout << "Bin nodes: " << binNodes.size() << endl;
	}
	*/


	//void getUnitigLengths(const string& gfa_filename){
	//	u_int64_t nbUnitigs = GfaParser::getUnitigLengths(gfa_filename, _unitigLengths);
	//}

	/*
	void computeNodeAbundance(MDBG* mdbg, const string& gfa_filename){

		string gfa_filename_unitig = gfa_filename + "_tmp.gfa";

		string command = "gfatools asm -u " + gfa_filename + " > " + gfa_filename_unitig;
		
		cout << command << endl;
		int ret = system(command.c_str());
		if(ret != 0){
			cout << "ERROR IN GFA TOOLS" << endl;
			exit(ret);
		}

		vector<int32_t> node_to_unitig(mdbg->_dbg_nodes.size(), -1);
		u_int64_t nbUnitigs = GfaParser::getNodeToUnitig(gfa_filename_unitig, node_to_unitig);

		cout << nbUnitigs << endl;
		
		_nodeAbundances.resize(mdbg->_dbg_nodes.size(), 0);
		vector<u_int32_t> unitigAbundances(nbUnitigs, 0);
		vector<u_int32_t> unitigAbundancesSize(nbUnitigs, 0);

		for(auto it : mdbg->_dbg_nodes){

			const KmerVec& vec = it.first;

			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;
			//u_int32_t unitigIndex = node_to_unitig[kminmer_index];
			//if(unitigIndex == -1) continue;

			//unitigDatas[unitigIndex]._nbKminmers += 1;
			//unitigDatas[unitigIndex]._meanAbundance += mdbg->_dbg_nodes[vec]._abundance;
			u_int32_t unitigIndex = node_to_unitig[kminmer_index];
			//if(unitigIndex == -1) continue;

			if(mdbg->_dbg_nodes[vec]._abundance > unitigAbundances[unitigIndex]){
				unitigAbundances[unitigIndex] = mdbg->_dbg_nodes[vec]._abundance;
			}
			//unitigAbundances[unitigIndex] = max(unitigAbundances[unitigIndex], mdbg->_dbg_nodes[vec]._abundance);
			//unitigAbundancesSize[unitigIndex] += 1;

			//_unitigDatas[kminmer_index]._meanAbundance += mdbg->_dbg_nodes[vec]._abundance;
			//_unitigDatas[kminmer_index]._nbKminmers += 1;
		}
		
		for(auto it : mdbg->_dbg_nodes){
			const KmerVec& vec = it.first;
			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;

			u_int32_t unitigIndex = node_to_unitig[kminmer_index];
			//_unitigDatas[unitigIndex]._meanAbundance = unitigAbundances[unitigIndex];
			_nodeAbundances[kminmer_index] = unitigAbundances[unitigIndex];
			//if(unitigIndex == -1) continue;

			//_unitigDatas[kminmer_index]._meanAbundance = unitigAbundances[unitigIndex]; // ((float) unitigAbundances[unitigIndex]) / unitigAbundancesSize[unitigIndex];
		}

		std::remove(gfa_filename_unitig.c_str());

		
		cout << mdbg->_dbg_nodes.size() << endl;
		float abundanceCutoff_min = 4.2;
		unordered_set<u_int32_t> nodes;
		for(auto it : mdbg->_dbg_nodes){
			const KmerVec& vec = it.first;
			u_int32_t kminmer_index = mdbg->_dbg_nodes[vec]._index;

			u_int32_t unitigIndex = node_to_unitig[kminmer_index];
			//if(unitigIndex == -1) continue;

			//_unitigDatas[kminmer_index]._meanAbundance = unitigAbundances[unitigIndex]; // ((float) unitigAbundances[unitigIndex]) / unitigAbundancesSize[unitigIndex];
			//if(_unitigDatas[unitigIndex]._meanAbundance > abundanceCutoff_min){
			if(_nodeAbundances[kminmer_index] > abundanceCutoff_min){
				nodes.insert(kminmer_index);
			}
		}
		GfaParser::rewriteGfa_withNodes(gfa_filename, gfa_filename + "_debug_filterByAbundance.gfa", nodes);
		cout << nodes.size() << endl;
		
		//size_t i=0;
		//for(UnitigData& data : _unitigDatas){
		//	cout << i << " " << data._meanAbundance << endl;
		//	i += 1;
		//}
	}*/









































































/*
void solveBin(u_int32_t utg, AdjGraph* graph, const vector<UnitigData>& unitigDatas, ofstream& file, int color){



		unordered_set<u_int32_t> binNodes;

		stack<ReadIndexType> stack;
		stack.push(utg);
		binNodes.insert(utg);
		unordered_set<u_int32_t> isNodeVisisted;
		unordered_map<DbgEdge, float, hash_pair> cache_distanceTnf;




		while (!stack.empty()){
			
			utg = stack.top();
			stack.pop();


			file << GfaParser::unitigIndex_to_unitigName(utg) << "," << color << endl;





			vector<u_int32_t> neighbors;
			//unordered_set<u_int32_t> neighborsShar

			//collectNeighbors_sharingReads(graph, utg, unitigDatas, neighbors, binNodes);
			graph->collectNeighbors(utg, 1, neighbors);
			//if(neighbors.size() == 0) continue;

			cout << "---------------" << endl;
			cout << GfaParser::unitigIndex_to_unitigName(utg) << endl;

			for(u_int32_t utg_n : neighbors){
			
				if(isNodeVisisted.find(utg_n) != isNodeVisisted.end()){
					continue;
				}

				isNodeVisisted.insert(utg_n);


				float dist = euclidianDistance(unitigDatas[utg]._compositionMean, unitigDatas[utg_n]._compositionMean);
				cout << GfaParser::unitigIndex_to_unitigName(utg) << " " << GfaParser::unitigIndex_to_unitigName(utg_n) << " " << dist << endl;
				
				//if(binNodes.find(utg_n) != binNodes.end()){
					//node = node->next;
				//	continue;
				//}
				
				vector<float> tnf_distances;
				
				for(u_int32_t r1 : unitigDatas[utg]._readIndexes){
					for(u_int32_t r2 : unitigDatas[utg_n]._readIndexes){
						//if(r1 == r2) continue;
						
						DbgEdge readPair = {r1, r2};
						readPair = readPair.normalize();

						float distance_tnf = -1;
						if(cache_distanceTnf.find(readPair) != cache_distanceTnf.end()){
							//cout << "oyo" << endl;
							distance_tnf = cache_distanceTnf[readPair];
						}
						else{
							distance_tnf = computeDistanceTNF(_readDatas[r1], _readDatas[r2]);
							cache_distanceTnf[readPair] = distance_tnf;
						}
						
					
						tnf_distances.push_back(distance_tnf);

					}
					
				}

				float median = compute_median_float(tnf_distances);
				cout << median << endl;

				u_int64_t nbSharedReads = computeSharedReads(unitigDatas[utg], unitigDatas[utg_n]);
				if(nbSharedReads <= 1) continue;

				stack.push(utg_n);
				binNodes.insert(utg_n);
				cout << "Bin nodes: " << binNodes.size() << " " << GfaParser::unitigIndex_to_unitigName(utg_n) << endl;
				


			}

		}

		cout << "Bin nodes: " << binNodes.size() << endl;
	}
*/


